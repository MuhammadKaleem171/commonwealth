/* tslint:disable */
/* eslint-disable */
/**
 * Common API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { AxiosInstance, AxiosPromise, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import type { Configuration } from './configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import type { RequestArgs } from './base';
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setBearerAuthToObject,
  setSearchParams,
  toPathString,
} from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface MutationCommunityCreateGroupRequest
 */
export interface MutationCommunityCreateGroupRequest {
  /**
   *
   * @type {MutationCommunityCreateGroupRequestMetadata}
   * @memberof MutationCommunityCreateGroupRequest
   */
  metadata: MutationCommunityCreateGroupRequestMetadata;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInner>}
   * @memberof MutationCommunityCreateGroupRequest
   */
  requirements: Array<QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInner>;
  /**
   *
   * @type {Array<number>}
   * @memberof MutationCommunityCreateGroupRequest
   */
  topics?: Array<number>;
}
/**
 *
 * @export
 * @interface MutationCommunityCreateGroupRequestMetadata
 */
export interface MutationCommunityCreateGroupRequestMetadata {
  /**
   *
   * @type {string}
   * @memberof MutationCommunityCreateGroupRequestMetadata
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof MutationCommunityCreateGroupRequestMetadata
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof MutationCommunityCreateGroupRequestMetadata
   */
  required_requirements?: number;
  /**
   *
   * @type {number}
   * @memberof MutationCommunityCreateGroupRequestMetadata
   */
  membership_ttl?: number;
}
/**
 *
 * @export
 * @interface MutationCommunityCreateStakeTransactionRequest
 */
export interface MutationCommunityCreateStakeTransactionRequest {
  /**
   *
   * @type {string}
   * @memberof MutationCommunityCreateStakeTransactionRequest
   */
  transaction_hash: string;
  /**
   *
   * @type {string}
   * @memberof MutationCommunityCreateStakeTransactionRequest
   */
  community_id: string;
}
/**
 *
 * @export
 * @interface MutationCommunitySetStake200Response
 */
export interface MutationCommunitySetStake200Response {
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof MutationCommunitySetStake200Response
   */
  chain_node_id: number;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  default_symbol?: string;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  network?: MutationCommunitySetStake200ResponseNetworkEnum;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  base: MutationCommunitySetStake200ResponseBaseEnum;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  icon_url?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof MutationCommunitySetStake200Response
   */
  active: boolean;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  type?: MutationCommunitySetStake200ResponseTypeEnum;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof MutationCommunitySetStake200Response
   */
  social_links?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof MutationCommunitySetStake200Response
   */
  ss58_prefix?: number;
  /**
   *
   * @type {boolean}
   * @memberof MutationCommunitySetStake200Response
   */
  stages_enabled?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof MutationCommunitySetStake200Response
   */
  custom_stages?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  custom_domain?: string;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  block_explorer_ids?: string;
  /**
   *
   * @type {boolean}
   * @memberof MutationCommunitySetStake200Response
   */
  collapsed_on_homepage?: boolean;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  substrate_spec?: string;
  /**
   *
   * @type {boolean}
   * @memberof MutationCommunitySetStake200Response
   */
  has_chain_events_listener?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MutationCommunitySetStake200Response
   */
  default_summary_view?: boolean;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  default_page?: MutationCommunitySetStake200ResponseDefaultPageEnum;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  has_homepage?: MutationCommunitySetStake200ResponseHasHomepageEnum | null;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  terms?: string;
  /**
   *
   * @type {boolean}
   * @memberof MutationCommunitySetStake200Response
   */
  admin_only_polling?: boolean;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  bech32_prefix?: string;
  /**
   *
   * @type {boolean}
   * @memberof MutationCommunitySetStake200Response
   */
  hide_projects?: boolean;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  token_name?: string;
  /**
   *
   * @type {boolean}
   * @memberof MutationCommunitySetStake200Response
   */
  ce_verbose?: boolean;
  /**
   *
   * @type {number}
   * @memberof MutationCommunitySetStake200Response
   */
  discord_config_id?: number | null;
  /**
   *
   * @type {any}
   * @memberof MutationCommunitySetStake200Response
   */
  category?: any;
  /**
   *
   * @type {boolean}
   * @memberof MutationCommunitySetStake200Response
   */
  discord_bot_webhooks_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MutationCommunitySetStake200Response
   */
  directory_page_enabled?: boolean;
  /**
   *
   * @type {number}
   * @memberof MutationCommunitySetStake200Response
   */
  directory_page_chain_node_id?: number;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  namespace?: string;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  namespace_address?: string;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  redirect?: string;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStake200Response
   */
  updated_at?: string;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseAddressesInner>}
   * @memberof MutationCommunitySetStake200Response
   */
  Addresses?: Array<QueryCommunityGetCommunity200ResponseAddressesInner>;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseCommunityStakesInner>}
   * @memberof MutationCommunitySetStake200Response
   */
  CommunityStakes?: Array<QueryCommunityGetCommunity200ResponseCommunityStakesInner>;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseCommunityTagsInner>}
   * @memberof MutationCommunitySetStake200Response
   */
  CommunityTags?: Array<QueryCommunityGetCommunity200ResponseCommunityTagsInner>;
  /**
   *
   * @type {QueryCommunityGetCommunity200ResponseChainNode}
   * @memberof MutationCommunitySetStake200Response
   */
  ChainNode?: QueryCommunityGetCommunity200ResponseChainNode;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseTopicsInner>}
   * @memberof MutationCommunitySetStake200Response
   */
  topics?: Array<QueryCommunityGetCommunity200ResponseTopicsInner>;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseGroupsInner>}
   * @memberof MutationCommunitySetStake200Response
   */
  groups?: Array<QueryCommunityGetCommunity200ResponseGroupsInner>;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseContestManagersInner>}
   * @memberof MutationCommunitySetStake200Response
   */
  contest_managers?: Array<QueryCommunityGetCommunity200ResponseContestManagersInner>;
  /**
   *
   * @type {Array<string>}
   * @memberof MutationCommunitySetStake200Response
   */
  snapshot_spaces?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof MutationCommunitySetStake200Response
   */
  include_in_digest_email?: boolean | null;
}

export const MutationCommunitySetStake200ResponseNetworkEnum = {
  Edgeware: 'edgeware',
  EdgewareTestnet: 'edgeware-testnet',
  Kusama: 'kusama',
  Kulupu: 'kulupu',
  Polkadot: 'polkadot',
  Plasm: 'plasm',
  Stafi: 'stafi',
  Darwinia: 'darwinia',
  Phala: 'phala',
  Centrifuge: 'centrifuge',
  Straightedge: 'straightedge',
  Osmosis: 'osmosis',
  Injective: 'injective',
  InjectiveTestnet: 'injective-testnet',
  Terra: 'terra',
  Ethereum: 'ethereum',
  Near: 'near',
  NearTestnet: 'near-testnet',
  Compound: 'compound',
  Aave: 'aave',
  AaveLocal: 'aave-local',
  Dydx: 'dydx',
  Metacartel: 'metacartel',
  Alex: 'alex',
  Erc20: 'erc20',
  Erc721: 'erc721',
  Erc1155: 'erc1155',
  Cw20: 'cw20',
  Cw721: 'cw721',
  Clover: 'clover',
  Hydradx: 'hydradx',
  Crust: 'crust',
  Sputnik: 'sputnik',
  SolanaDevnet: 'solana-devnet',
  SolanaTestnet: 'solana-testnet',
  Solana: 'solana',
  Spl: 'spl',
  Evmos: 'evmos',
  Kava: 'kava',
  Kyve: 'kyve',
  Stargaze: 'stargaze',
  Cosmos: 'cosmos',
} as const;

export type MutationCommunitySetStake200ResponseNetworkEnum =
  typeof MutationCommunitySetStake200ResponseNetworkEnum[keyof typeof MutationCommunitySetStake200ResponseNetworkEnum];
export const MutationCommunitySetStake200ResponseBaseEnum = {
  Cosmos: 'cosmos',
  Substrate: 'substrate',
  Ethereum: 'ethereum',
  Near: 'near',
  Solana: 'solana',
} as const;

export type MutationCommunitySetStake200ResponseBaseEnum =
  typeof MutationCommunitySetStake200ResponseBaseEnum[keyof typeof MutationCommunitySetStake200ResponseBaseEnum];
export const MutationCommunitySetStake200ResponseTypeEnum = {
  Chain: 'chain',
  Dao: 'dao',
  Token: 'token',
  Offchain: 'offchain',
} as const;

export type MutationCommunitySetStake200ResponseTypeEnum =
  typeof MutationCommunitySetStake200ResponseTypeEnum[keyof typeof MutationCommunitySetStake200ResponseTypeEnum];
export const MutationCommunitySetStake200ResponseDefaultPageEnum = {
  AllDiscussionsView: 'default_all_discussions_view',
  SummaryView: 'default_summary_view',
} as const;

export type MutationCommunitySetStake200ResponseDefaultPageEnum =
  typeof MutationCommunitySetStake200ResponseDefaultPageEnum[keyof typeof MutationCommunitySetStake200ResponseDefaultPageEnum];
export const MutationCommunitySetStake200ResponseHasHomepageEnum = {
  True: 'true',
  False: 'false',
} as const;

export type MutationCommunitySetStake200ResponseHasHomepageEnum =
  typeof MutationCommunitySetStake200ResponseHasHomepageEnum[keyof typeof MutationCommunitySetStake200ResponseHasHomepageEnum];

/**
 *
 * @export
 * @interface MutationCommunitySetStakeRequest
 */
export interface MutationCommunitySetStakeRequest {
  /**
   *
   * @type {number}
   * @memberof MutationCommunitySetStakeRequest
   */
  stake_id: number;
  /**
   *
   * @type {string}
   * @memberof MutationCommunitySetStakeRequest
   */
  stake_token?: string;
  /**
   *
   * @type {number}
   * @memberof MutationCommunitySetStakeRequest
   */
  vote_weight?: number;
  /**
   *
   * @type {boolean}
   * @memberof MutationCommunitySetStakeRequest
   */
  stake_enabled?: boolean;
}
/**
 *
 * @export
 * @interface MutationContestCreateContestMetadata200Response
 */
export interface MutationContestCreateContestMetadata200Response {
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseContestManagersInner>}
   * @memberof MutationContestCreateContestMetadata200Response
   */
  contest_managers: Array<QueryCommunityGetCommunity200ResponseContestManagersInner>;
}
/**
 *
 * @export
 * @interface MutationContestCreateContestMetadataRequest
 */
export interface MutationContestCreateContestMetadataRequest {
  /**
   * On-Chain contest manager address
   * @type {string}
   * @memberof MutationContestCreateContestMetadataRequest
   */
  contest_address: string;
  /**
   *
   * @type {string}
   * @memberof MutationContestCreateContestMetadataRequest
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof MutationContestCreateContestMetadataRequest
   */
  image_url?: string;
  /**
   * Provided by admin on creation when stake funds are not used
   * @type {string}
   * @memberof MutationContestCreateContestMetadataRequest
   */
  funding_token_address?: string;
  /**
   * Percentage of pool used for prizes in recurring contests
   * @type {number}
   * @memberof MutationContestCreateContestMetadataRequest
   */
  prize_percentage?: number;
  /**
   * Sorted array of percentages for prize, from first to last
   * @type {Array<number>}
   * @memberof MutationContestCreateContestMetadataRequest
   */
  payout_structure: Array<number>;
  /**
   * Recurring contest interval in seconds, 0 when one-off
   * @type {number}
   * @memberof MutationContestCreateContestMetadataRequest
   */
  interval: number;
  /**
   *
   * @type {string}
   * @memberof MutationContestCreateContestMetadataRequest
   */
  ticker?: string;
  /**
   *
   * @type {number}
   * @memberof MutationContestCreateContestMetadataRequest
   */
  decimals?: number;
  /**
   *
   * @type {Array<number>}
   * @memberof MutationContestCreateContestMetadataRequest
   */
  topic_ids?: Array<number>;
}
/**
 *
 * @export
 * @interface MutationContestUpdateContestMetadataRequest
 */
export interface MutationContestUpdateContestMetadataRequest {
  /**
   * On-Chain contest manager address
   * @type {string}
   * @memberof MutationContestUpdateContestMetadataRequest
   */
  contest_address: string;
  /**
   *
   * @type {string}
   * @memberof MutationContestUpdateContestMetadataRequest
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof MutationContestUpdateContestMetadataRequest
   */
  image_url?: string;
  /**
   *
   * @type {Array<number>}
   * @memberof MutationContestUpdateContestMetadataRequest
   */
  topic_ids?: Array<number>;
}
/**
 *
 * @export
 * @interface MutationIntegrationsAnalyticsRequest
 */
export interface MutationIntegrationsAnalyticsRequest {
  /**
   *
   * @type {MutationIntegrationsAnalyticsRequestGroupCreated}
   * @memberof MutationIntegrationsAnalyticsRequest
   */
  GroupCreated: MutationIntegrationsAnalyticsRequestGroupCreated;
  /**
   *
   * @type {MutationIntegrationsAnalyticsRequestThreadCreated}
   * @memberof MutationIntegrationsAnalyticsRequest
   */
  ThreadCreated: MutationIntegrationsAnalyticsRequestThreadCreated;
  /**
   *
   * @type {MutationIntegrationsAnalyticsRequestCommentCreated}
   * @memberof MutationIntegrationsAnalyticsRequest
   */
  CommentCreated: MutationIntegrationsAnalyticsRequestCommentCreated;
}
/**
 *
 * @export
 * @interface MutationIntegrationsAnalyticsRequestCommentCreated
 */
export interface MutationIntegrationsAnalyticsRequestCommentCreated {
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  thread_id: number;
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  address_id: number;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  text: string;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  plaintext: string;
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  parent_id?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  version_history?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  version_history_updated?: boolean;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  canvas_signed_data: string;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  canvas_hash: string;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  created_by?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  created_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  updated_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  deleted_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  marked_as_spam_at?: string | null;
  /**
   *
   * @type {QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  discord_meta?: QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta | null;
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  reaction_count: number;
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  reaction_weights_sum?: number;
  /**
   *
   * @type {MutationIntegrationsAnalyticsRequestThreadCreatedAddress}
   * @memberof MutationIntegrationsAnalyticsRequestCommentCreated
   */
  Address?: MutationIntegrationsAnalyticsRequestThreadCreatedAddress | null;
}
/**
 *
 * @export
 * @interface MutationIntegrationsAnalyticsRequestGroupCreated
 */
export interface MutationIntegrationsAnalyticsRequestGroupCreated {
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestGroupCreated
   */
  groupId: string;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestGroupCreated
   */
  userId: string;
}
/**
 *
 * @export
 * @interface MutationIntegrationsAnalyticsRequestThreadCreated
 */
export interface MutationIntegrationsAnalyticsRequestThreadCreated {
  /**
   *
   * @type {MutationIntegrationsAnalyticsRequestThreadCreatedAddress}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  Address?: MutationIntegrationsAnalyticsRequestThreadCreatedAddress | null;
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  address_id: number;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  kind: string;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  stage: string;
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  body?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  plaintext?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  url?: string | null;
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  topic_id?: number | null;
  /**
   *
   * @type {boolean}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  pinned?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  community_id: string;
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  view_count: number;
  /**
   *
   * @type {Array<QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInner>}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  links?: Array<QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInner> | null;
  /**
   *
   * @type {boolean}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  read_only?: boolean | null;
  /**
   *
   * @type {Array<string>}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  version_history?: Array<string> | null;
  /**
   *
   * @type {boolean}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  has_poll?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  canvas_signed_data?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  canvas_hash?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  created_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  updated_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  last_edited?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  deleted_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  last_commented_on?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  marked_as_spam_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  archived_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  locked_at?: string | null;
  /**
   *
   * @type {QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  discord_meta?: QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta | null;
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  reaction_count: number;
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  reaction_weights_sum: number;
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  comment_count: number;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  activity_rank_date?: string | null;
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  max_notif_id: number;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  created_by?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  profile_name?: string | null;
  /**
   *
   * @type {Array<MutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner>}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreated
   */
  contestManagers?: Array<MutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner> | null;
}
/**
 *
 * @export
 * @interface MutationIntegrationsAnalyticsRequestThreadCreatedAddress
 */
export interface MutationIntegrationsAnalyticsRequestThreadCreatedAddress {
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  community_id?: string;
  /**
   *
   * @type {number}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  user_id?: number | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  verification_token?: string;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  verification_token_expires?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  verified?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  last_active?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  is_councillor?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  is_validator?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  ghost_address?: boolean;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  wallet_id?: MutationIntegrationsAnalyticsRequestThreadCreatedAddressWalletIdEnum;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  block_info?: string;
  /**
   *
   * @type {boolean}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  is_user_default?: boolean;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  role?: MutationIntegrationsAnalyticsRequestThreadCreatedAddressRoleEnum;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  wallet_sso_source?: MutationIntegrationsAnalyticsRequestThreadCreatedAddressWalletSsoSourceEnum;
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  hex?: string;
  /**
   *
   * @type {any}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  created_at?: any;
  /**
   *
   * @type {any}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  updated_at?: any;
  /**
   *
   * @type {MutationUserUpdateUser200Response}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedAddress
   */
  User?: MutationUserUpdateUser200Response;
}

export const MutationIntegrationsAnalyticsRequestThreadCreatedAddressWalletIdEnum =
  {
    Magic: 'magic',
    Polkadot: 'polkadot',
    Metamask: 'metamask',
    Walletconnect: 'walletconnect',
    KeplrEthereum: 'keplr-ethereum',
    Keplr: 'keplr',
    Leap: 'leap',
    Near: 'near',
    Terrastation: 'terrastation',
    TerraWalletconnect: 'terra-walletconnect',
    CosmMetamask: 'cosm-metamask',
    Phantom: 'phantom',
    Coinbase: 'coinbase',
  } as const;

export type MutationIntegrationsAnalyticsRequestThreadCreatedAddressWalletIdEnum =
  typeof MutationIntegrationsAnalyticsRequestThreadCreatedAddressWalletIdEnum[keyof typeof MutationIntegrationsAnalyticsRequestThreadCreatedAddressWalletIdEnum];
export const MutationIntegrationsAnalyticsRequestThreadCreatedAddressRoleEnum =
  {
    Admin: 'admin',
    Moderator: 'moderator',
    Member: 'member',
  } as const;

export type MutationIntegrationsAnalyticsRequestThreadCreatedAddressRoleEnum =
  typeof MutationIntegrationsAnalyticsRequestThreadCreatedAddressRoleEnum[keyof typeof MutationIntegrationsAnalyticsRequestThreadCreatedAddressRoleEnum];
export const MutationIntegrationsAnalyticsRequestThreadCreatedAddressWalletSsoSourceEnum =
  {
    Google: 'google',
    Github: 'github',
    Discord: 'discord',
    Twitter: 'twitter',
    Apple: 'apple',
    Email: 'email',
    Unknown: 'unknown',
  } as const;

export type MutationIntegrationsAnalyticsRequestThreadCreatedAddressWalletSsoSourceEnum =
  typeof MutationIntegrationsAnalyticsRequestThreadCreatedAddressWalletSsoSourceEnum[keyof typeof MutationIntegrationsAnalyticsRequestThreadCreatedAddressWalletSsoSourceEnum];

/**
 *
 * @export
 * @interface MutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner
 */
export interface MutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner {
  /**
   *
   * @type {string}
   * @memberof MutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner
   */
  contest_address: string;
}
/**
 *
 * @export
 * @interface MutationLoadTestCreateJWTsRequest
 */
export interface MutationLoadTestCreateJWTsRequest {
  /**
   *
   * @type {number}
   * @memberof MutationLoadTestCreateJWTsRequest
   */
  number_of_jwt: number;
}
/**
 *
 * @export
 * @interface MutationSubscriptionCreateCommentSubscription200Response
 */
export interface MutationSubscriptionCreateCommentSubscription200Response {
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateCommentSubscription200Response
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateCommentSubscription200Response
   */
  user_id: number;
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateCommentSubscription200Response
   */
  comment_id: number;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200Response
   */
  updated_at?: string;
  /**
   *
   * @type {MutationSubscriptionCreateCommentSubscription200ResponseComment}
   * @memberof MutationSubscriptionCreateCommentSubscription200Response
   */
  Comment?: MutationSubscriptionCreateCommentSubscription200ResponseComment;
}
/**
 *
 * @export
 * @interface MutationSubscriptionCreateCommentSubscription200ResponseComment
 */
export interface MutationSubscriptionCreateCommentSubscription200ResponseComment {
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseComment
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseComment
   */
  created_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseComment
   */
  updated_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseComment
   */
  text: string;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseComment
   */
  plaintext: string;
  /**
   *
   * @type {MutationSubscriptionCreateCommentSubscription200ResponseCommentThread}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseComment
   */
  Thread: MutationSubscriptionCreateCommentSubscription200ResponseCommentThread;
}
/**
 *
 * @export
 * @interface MutationSubscriptionCreateCommentSubscription200ResponseCommentThread
 */
export interface MutationSubscriptionCreateCommentSubscription200ResponseCommentThread {
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  comment_count: number;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  created_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  url?: string | null;
  /**
   *
   * @type {MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  Community: MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity;
  /**
   *
   * @type {MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadAddress}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  Address: MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadAddress;
}
/**
 *
 * @export
 * @interface MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadAddress
 */
export interface MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadAddress {
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadAddress
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadAddress
   */
  user_id?: number | null;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadAddress
   */
  address: string;
}
/**
 *
 * @export
 * @interface MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity
 */
export interface MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity {
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity
   */
  icon_url?: string | null;
}
/**
 *
 * @export
 * @interface MutationSubscriptionCreateCommentSubscriptionRequest
 */
export interface MutationSubscriptionCreateCommentSubscriptionRequest {
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateCommentSubscriptionRequest
   */
  comment_id: number;
}
/**
 *
 * @export
 * @interface MutationSubscriptionCreateCommunityAlert200Response
 */
export interface MutationSubscriptionCreateCommunityAlert200Response {
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateCommunityAlert200Response
   */
  user_id: number;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommunityAlert200Response
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommunityAlert200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommunityAlert200Response
   */
  updated_at?: string;
  /**
   *
   * @type {MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity}
   * @memberof MutationSubscriptionCreateCommunityAlert200Response
   */
  Community?: MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity;
}
/**
 *
 * @export
 * @interface MutationSubscriptionCreateCommunityAlertRequest
 */
export interface MutationSubscriptionCreateCommunityAlertRequest {
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateCommunityAlertRequest
   */
  community_id: string;
}
/**
 *
 * @export
 * @interface MutationSubscriptionCreateThreadSubscription200Response
 */
export interface MutationSubscriptionCreateThreadSubscription200Response {
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateThreadSubscription200Response
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateThreadSubscription200Response
   */
  user_id: number;
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateThreadSubscription200Response
   */
  thread_id: number;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateThreadSubscription200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateThreadSubscription200Response
   */
  updated_at?: string;
  /**
   *
   * @type {MutationSubscriptionCreateThreadSubscription200ResponseThread}
   * @memberof MutationSubscriptionCreateThreadSubscription200Response
   */
  Thread?: MutationSubscriptionCreateThreadSubscription200ResponseThread;
}
/**
 *
 * @export
 * @interface MutationSubscriptionCreateThreadSubscription200ResponseThread
 */
export interface MutationSubscriptionCreateThreadSubscription200ResponseThread {
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateThreadSubscription200ResponseThread
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateThreadSubscription200ResponseThread
   */
  community_id: string;
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateThreadSubscription200ResponseThread
   */
  address_id: number;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateThreadSubscription200ResponseThread
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateThreadSubscription200ResponseThread
   */
  comment_count: number;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateThreadSubscription200ResponseThread
   */
  created_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionCreateThreadSubscription200ResponseThread
   */
  url?: string | null;
  /**
   *
   * @type {MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity}
   * @memberof MutationSubscriptionCreateThreadSubscription200ResponseThread
   */
  Community: MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity;
  /**
   *
   * @type {MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadAddress}
   * @memberof MutationSubscriptionCreateThreadSubscription200ResponseThread
   */
  Address: MutationSubscriptionCreateCommentSubscription200ResponseCommentThreadAddress;
}
/**
 *
 * @export
 * @interface MutationSubscriptionCreateThreadSubscriptionRequest
 */
export interface MutationSubscriptionCreateThreadSubscriptionRequest {
  /**
   *
   * @type {number}
   * @memberof MutationSubscriptionCreateThreadSubscriptionRequest
   */
  thread_id: number;
}
/**
 *
 * @export
 * @interface MutationSubscriptionDeleteCommentSubscriptionRequest
 */
export interface MutationSubscriptionDeleteCommentSubscriptionRequest {
  /**
   *
   * @type {Array<number>}
   * @memberof MutationSubscriptionDeleteCommentSubscriptionRequest
   */
  comment_ids: Array<number>;
}
/**
 *
 * @export
 * @interface MutationSubscriptionDeleteCommunityAlertRequest
 */
export interface MutationSubscriptionDeleteCommunityAlertRequest {
  /**
   *
   * @type {Array<string>}
   * @memberof MutationSubscriptionDeleteCommunityAlertRequest
   */
  community_ids: Array<string>;
}
/**
 *
 * @export
 * @interface MutationSubscriptionDeleteThreadSubscriptionRequest
 */
export interface MutationSubscriptionDeleteThreadSubscriptionRequest {
  /**
   *
   * @type {Array<number>}
   * @memberof MutationSubscriptionDeleteThreadSubscriptionRequest
   */
  thread_ids: Array<number>;
}
/**
 *
 * @export
 * @interface MutationSubscriptionRegisterClientRegistrationTokenRequest
 */
export interface MutationSubscriptionRegisterClientRegistrationTokenRequest {
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionRegisterClientRegistrationTokenRequest
   */
  token: string;
  /**
   *
   * @type {string}
   * @memberof MutationSubscriptionRegisterClientRegistrationTokenRequest
   */
  channelType: MutationSubscriptionRegisterClientRegistrationTokenRequestChannelTypeEnum;
}

export const MutationSubscriptionRegisterClientRegistrationTokenRequestChannelTypeEnum =
  {
    Apns: 'APNS',
    Fcm: 'FCM',
  } as const;

export type MutationSubscriptionRegisterClientRegistrationTokenRequestChannelTypeEnum =
  typeof MutationSubscriptionRegisterClientRegistrationTokenRequestChannelTypeEnum[keyof typeof MutationSubscriptionRegisterClientRegistrationTokenRequestChannelTypeEnum];

/**
 *
 * @export
 * @interface MutationSubscriptionUpdateSubscriptionPreferencesRequest
 */
export interface MutationSubscriptionUpdateSubscriptionPreferencesRequest {
  /**
   *
   * @type {boolean}
   * @memberof MutationSubscriptionUpdateSubscriptionPreferencesRequest
   */
  email_notifications_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MutationSubscriptionUpdateSubscriptionPreferencesRequest
   */
  digest_email_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MutationSubscriptionUpdateSubscriptionPreferencesRequest
   */
  recap_email_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MutationSubscriptionUpdateSubscriptionPreferencesRequest
   */
  mobile_push_notifications_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MutationSubscriptionUpdateSubscriptionPreferencesRequest
   */
  mobile_push_discussion_activity_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MutationSubscriptionUpdateSubscriptionPreferencesRequest
   */
  mobile_push_admin_alerts_enabled?: boolean;
}
/**
 *
 * @export
 * @interface MutationUserUpdateUser200Response
 */
export interface MutationUserUpdateUser200Response {
  /**
   *
   * @type {number}
   * @memberof MutationUserUpdateUser200Response
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUser200Response
   */
  email?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof MutationUserUpdateUser200Response
   */
  isAdmin?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MutationUserUpdateUser200Response
   */
  disableRichText?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MutationUserUpdateUser200Response
   */
  emailVerified?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUser200Response
   */
  selected_community_id?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUser200Response
   */
  emailNotificationInterval?: MutationUserUpdateUser200ResponseEmailNotificationIntervalEnum;
  /**
   *
   * @type {boolean}
   * @memberof MutationUserUpdateUser200Response
   */
  promotional_emails_enabled?: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof MutationUserUpdateUser200Response
   */
  is_welcome_onboard_flow_complete?: boolean;
  /**
   *
   * @type {MutationUserUpdateUserRequestProfile}
   * @memberof MutationUserUpdateUser200Response
   */
  profile: MutationUserUpdateUserRequestProfile;
  /**
   *
   * @type {any}
   * @memberof MutationUserUpdateUser200Response
   */
  created_at?: any;
  /**
   *
   * @type {any}
   * @memberof MutationUserUpdateUser200Response
   */
  updated_at?: any;
  /**
   *
   * @type {Array<MutationUserUpdateUserRequestProfileTagsInner>}
   * @memberof MutationUserUpdateUser200Response
   */
  ProfileTags?: Array<MutationUserUpdateUserRequestProfileTagsInner>;
}

export const MutationUserUpdateUser200ResponseEmailNotificationIntervalEnum = {
  Weekly: 'weekly',
  Never: 'never',
} as const;

export type MutationUserUpdateUser200ResponseEmailNotificationIntervalEnum =
  typeof MutationUserUpdateUser200ResponseEmailNotificationIntervalEnum[keyof typeof MutationUserUpdateUser200ResponseEmailNotificationIntervalEnum];

/**
 *
 * @export
 * @interface MutationUserUpdateUserDefaultResponse
 */
export interface MutationUserUpdateUserDefaultResponse {
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserDefaultResponse
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserDefaultResponse
   */
  code: string;
  /**
   *
   * @type {Array<MutationUserUpdateUserDefaultResponseIssuesInner>}
   * @memberof MutationUserUpdateUserDefaultResponse
   */
  issues?: Array<MutationUserUpdateUserDefaultResponseIssuesInner>;
}
/**
 *
 * @export
 * @interface MutationUserUpdateUserDefaultResponseIssuesInner
 */
export interface MutationUserUpdateUserDefaultResponseIssuesInner {
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserDefaultResponseIssuesInner
   */
  message: string;
}
/**
 *
 * @export
 * @interface MutationUserUpdateUserRequest
 */
export interface MutationUserUpdateUserRequest {
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserRequest
   */
  email?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof MutationUserUpdateUserRequest
   */
  isAdmin?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MutationUserUpdateUserRequest
   */
  disableRichText?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MutationUserUpdateUserRequest
   */
  emailVerified?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserRequest
   */
  selected_community_id?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserRequest
   */
  emailNotificationInterval?: MutationUserUpdateUserRequestEmailNotificationIntervalEnum;
  /**
   *
   * @type {boolean}
   * @memberof MutationUserUpdateUserRequest
   */
  promotional_emails_enabled?: boolean | null;
  /**
   *
   * @type {MutationUserUpdateUserRequestProfile}
   * @memberof MutationUserUpdateUserRequest
   */
  profile: MutationUserUpdateUserRequestProfile;
  /**
   *
   * @type {any}
   * @memberof MutationUserUpdateUserRequest
   */
  created_at?: any;
  /**
   *
   * @type {any}
   * @memberof MutationUserUpdateUserRequest
   */
  updated_at?: any;
  /**
   *
   * @type {Array<MutationUserUpdateUserRequestProfileTagsInner>}
   * @memberof MutationUserUpdateUserRequest
   */
  ProfileTags?: Array<MutationUserUpdateUserRequestProfileTagsInner>;
  /**
   *
   * @type {Array<number>}
   * @memberof MutationUserUpdateUserRequest
   */
  tag_ids?: Array<number> | null;
}

export const MutationUserUpdateUserRequestEmailNotificationIntervalEnum = {
  Weekly: 'weekly',
  Never: 'never',
} as const;

export type MutationUserUpdateUserRequestEmailNotificationIntervalEnum =
  typeof MutationUserUpdateUserRequestEmailNotificationIntervalEnum[keyof typeof MutationUserUpdateUserRequestEmailNotificationIntervalEnum];

/**
 *
 * @export
 * @interface MutationUserUpdateUserRequestProfile
 */
export interface MutationUserUpdateUserRequestProfile {
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserRequestProfile
   */
  name?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserRequestProfile
   */
  email?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserRequestProfile
   */
  website?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserRequestProfile
   */
  bio?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserRequestProfile
   */
  avatar_url?: string | null;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserRequestProfile
   */
  slug?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof MutationUserUpdateUserRequestProfile
   */
  socials?: Array<string> | null;
  /**
   *
   * @type {MutationUserUpdateUserRequestProfileBackgroundImage}
   * @memberof MutationUserUpdateUserRequestProfile
   */
  background_image?: MutationUserUpdateUserRequestProfileBackgroundImage | null;
}
/**
 *
 * @export
 * @interface MutationUserUpdateUserRequestProfileBackgroundImage
 */
export interface MutationUserUpdateUserRequestProfileBackgroundImage {
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserRequestProfileBackgroundImage
   */
  url?: string;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserRequestProfileBackgroundImage
   */
  imageBehavior?: string;
}
/**
 *
 * @export
 * @interface MutationUserUpdateUserRequestProfileTagsInner
 */
export interface MutationUserUpdateUserRequestProfileTagsInner {
  /**
   *
   * @type {number}
   * @memberof MutationUserUpdateUserRequestProfileTagsInner
   */
  user_id: number;
  /**
   *
   * @type {number}
   * @memberof MutationUserUpdateUserRequestProfileTagsInner
   */
  tag_id: number;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserRequestProfileTagsInner
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof MutationUserUpdateUserRequestProfileTagsInner
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200Response
 */
export interface QueryCommunityGetCommunity200Response {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200Response
   */
  chain_node_id: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  default_symbol?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  network?: QueryCommunityGetCommunity200ResponseNetworkEnum;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  base: QueryCommunityGetCommunity200ResponseBaseEnum;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  icon_url?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200Response
   */
  active: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  type?: QueryCommunityGetCommunity200ResponseTypeEnum;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof QueryCommunityGetCommunity200Response
   */
  social_links?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200Response
   */
  ss58_prefix?: number;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200Response
   */
  stages_enabled?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof QueryCommunityGetCommunity200Response
   */
  custom_stages?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  custom_domain?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  block_explorer_ids?: string;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200Response
   */
  collapsed_on_homepage?: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  substrate_spec?: string;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200Response
   */
  has_chain_events_listener?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200Response
   */
  default_summary_view?: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  default_page?: QueryCommunityGetCommunity200ResponseDefaultPageEnum;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  has_homepage?: QueryCommunityGetCommunity200ResponseHasHomepageEnum | null;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  terms?: string;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200Response
   */
  admin_only_polling?: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  bech32_prefix?: string;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200Response
   */
  hide_projects?: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  token_name?: string;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200Response
   */
  ce_verbose?: boolean;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200Response
   */
  discord_config_id?: number | null;
  /**
   *
   * @type {any}
   * @memberof QueryCommunityGetCommunity200Response
   */
  category?: any;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200Response
   */
  discord_bot_webhooks_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200Response
   */
  directory_page_enabled?: boolean;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200Response
   */
  directory_page_chain_node_id?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  namespace?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  namespace_address?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  redirect?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200Response
   */
  updated_at?: string;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseAddressesInner>}
   * @memberof QueryCommunityGetCommunity200Response
   */
  Addresses?: Array<QueryCommunityGetCommunity200ResponseAddressesInner>;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseCommunityStakesInner>}
   * @memberof QueryCommunityGetCommunity200Response
   */
  CommunityStakes?: Array<QueryCommunityGetCommunity200ResponseCommunityStakesInner>;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseCommunityTagsInner>}
   * @memberof QueryCommunityGetCommunity200Response
   */
  CommunityTags?: Array<QueryCommunityGetCommunity200ResponseCommunityTagsInner>;
  /**
   *
   * @type {QueryCommunityGetCommunity200ResponseChainNode}
   * @memberof QueryCommunityGetCommunity200Response
   */
  ChainNode?: QueryCommunityGetCommunity200ResponseChainNode;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseTopicsInner>}
   * @memberof QueryCommunityGetCommunity200Response
   */
  topics?: Array<QueryCommunityGetCommunity200ResponseTopicsInner>;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseGroupsInner>}
   * @memberof QueryCommunityGetCommunity200Response
   */
  groups?: Array<QueryCommunityGetCommunity200ResponseGroupsInner>;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseContestManagersInner>}
   * @memberof QueryCommunityGetCommunity200Response
   */
  contest_managers?: Array<QueryCommunityGetCommunity200ResponseContestManagersInner>;
  /**
   *
   * @type {Array<string>}
   * @memberof QueryCommunityGetCommunity200Response
   */
  snapshot_spaces?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200Response
   */
  include_in_digest_email?: boolean | null;
}

export const QueryCommunityGetCommunity200ResponseNetworkEnum = {
  Edgeware: 'edgeware',
  EdgewareTestnet: 'edgeware-testnet',
  Kusama: 'kusama',
  Kulupu: 'kulupu',
  Polkadot: 'polkadot',
  Plasm: 'plasm',
  Stafi: 'stafi',
  Darwinia: 'darwinia',
  Phala: 'phala',
  Centrifuge: 'centrifuge',
  Straightedge: 'straightedge',
  Osmosis: 'osmosis',
  Injective: 'injective',
  InjectiveTestnet: 'injective-testnet',
  Terra: 'terra',
  Ethereum: 'ethereum',
  Near: 'near',
  NearTestnet: 'near-testnet',
  Compound: 'compound',
  Aave: 'aave',
  AaveLocal: 'aave-local',
  Dydx: 'dydx',
  Metacartel: 'metacartel',
  Alex: 'alex',
  Erc20: 'erc20',
  Erc721: 'erc721',
  Erc1155: 'erc1155',
  Cw20: 'cw20',
  Cw721: 'cw721',
  Clover: 'clover',
  Hydradx: 'hydradx',
  Crust: 'crust',
  Sputnik: 'sputnik',
  SolanaDevnet: 'solana-devnet',
  SolanaTestnet: 'solana-testnet',
  Solana: 'solana',
  Spl: 'spl',
  Evmos: 'evmos',
  Kava: 'kava',
  Kyve: 'kyve',
  Stargaze: 'stargaze',
  Cosmos: 'cosmos',
} as const;

export type QueryCommunityGetCommunity200ResponseNetworkEnum =
  typeof QueryCommunityGetCommunity200ResponseNetworkEnum[keyof typeof QueryCommunityGetCommunity200ResponseNetworkEnum];
export const QueryCommunityGetCommunity200ResponseBaseEnum = {
  Cosmos: 'cosmos',
  Substrate: 'substrate',
  Ethereum: 'ethereum',
  Near: 'near',
  Solana: 'solana',
} as const;

export type QueryCommunityGetCommunity200ResponseBaseEnum =
  typeof QueryCommunityGetCommunity200ResponseBaseEnum[keyof typeof QueryCommunityGetCommunity200ResponseBaseEnum];
export const QueryCommunityGetCommunity200ResponseTypeEnum = {
  Chain: 'chain',
  Dao: 'dao',
  Token: 'token',
  Offchain: 'offchain',
} as const;

export type QueryCommunityGetCommunity200ResponseTypeEnum =
  typeof QueryCommunityGetCommunity200ResponseTypeEnum[keyof typeof QueryCommunityGetCommunity200ResponseTypeEnum];
export const QueryCommunityGetCommunity200ResponseDefaultPageEnum = {
  AllDiscussionsView: 'default_all_discussions_view',
  SummaryView: 'default_summary_view',
} as const;

export type QueryCommunityGetCommunity200ResponseDefaultPageEnum =
  typeof QueryCommunityGetCommunity200ResponseDefaultPageEnum[keyof typeof QueryCommunityGetCommunity200ResponseDefaultPageEnum];
export const QueryCommunityGetCommunity200ResponseHasHomepageEnum = {
  True: 'true',
  False: 'false',
} as const;

export type QueryCommunityGetCommunity200ResponseHasHomepageEnum =
  typeof QueryCommunityGetCommunity200ResponseHasHomepageEnum[keyof typeof QueryCommunityGetCommunity200ResponseHasHomepageEnum];

/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseAddressesInner
 */
export interface QueryCommunityGetCommunity200ResponseAddressesInner {
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  community_id?: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  user_id?: number | null;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  verification_token?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  verification_token_expires?: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  verified?: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  last_active?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  is_councillor?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  is_validator?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  ghost_address?: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  wallet_id?: QueryCommunityGetCommunity200ResponseAddressesInnerWalletIdEnum;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  block_info?: string;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  is_user_default?: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  role?: QueryCommunityGetCommunity200ResponseAddressesInnerRoleEnum;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  wallet_sso_source?: QueryCommunityGetCommunity200ResponseAddressesInnerWalletSsoSourceEnum;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  hex?: string;
  /**
   *
   * @type {any}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  created_at?: any;
  /**
   *
   * @type {any}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  updated_at?: any;
  /**
   *
   * @type {MutationUserUpdateUser200Response}
   * @memberof QueryCommunityGetCommunity200ResponseAddressesInner
   */
  User?: MutationUserUpdateUser200Response;
}

export const QueryCommunityGetCommunity200ResponseAddressesInnerWalletIdEnum = {
  Magic: 'magic',
  Polkadot: 'polkadot',
  Metamask: 'metamask',
  Walletconnect: 'walletconnect',
  KeplrEthereum: 'keplr-ethereum',
  Keplr: 'keplr',
  Leap: 'leap',
  Near: 'near',
  Terrastation: 'terrastation',
  TerraWalletconnect: 'terra-walletconnect',
  CosmMetamask: 'cosm-metamask',
  Phantom: 'phantom',
  Coinbase: 'coinbase',
} as const;

export type QueryCommunityGetCommunity200ResponseAddressesInnerWalletIdEnum =
  typeof QueryCommunityGetCommunity200ResponseAddressesInnerWalletIdEnum[keyof typeof QueryCommunityGetCommunity200ResponseAddressesInnerWalletIdEnum];
export const QueryCommunityGetCommunity200ResponseAddressesInnerRoleEnum = {
  Admin: 'admin',
  Moderator: 'moderator',
  Member: 'member',
} as const;

export type QueryCommunityGetCommunity200ResponseAddressesInnerRoleEnum =
  typeof QueryCommunityGetCommunity200ResponseAddressesInnerRoleEnum[keyof typeof QueryCommunityGetCommunity200ResponseAddressesInnerRoleEnum];
export const QueryCommunityGetCommunity200ResponseAddressesInnerWalletSsoSourceEnum =
  {
    Google: 'google',
    Github: 'github',
    Discord: 'discord',
    Twitter: 'twitter',
    Apple: 'apple',
    Email: 'email',
    Unknown: 'unknown',
  } as const;

export type QueryCommunityGetCommunity200ResponseAddressesInnerWalletSsoSourceEnum =
  typeof QueryCommunityGetCommunity200ResponseAddressesInnerWalletSsoSourceEnum[keyof typeof QueryCommunityGetCommunity200ResponseAddressesInnerWalletSsoSourceEnum];

/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseChainNode
 */
export interface QueryCommunityGetCommunity200ResponseChainNode {
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  url: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  eth_chain_id?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  alt_wallet_url?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  private_url?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  balance_type: QueryCommunityGetCommunity200ResponseChainNodeBalanceTypeEnum;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  ss58?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  bech32?: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  slip44?: number;
  /**
   *
   * @type {any}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  created_at?: any;
  /**
   *
   * @type {any}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  updated_at?: any;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  cosmos_chain_id?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  cosmos_gov_version?: QueryCommunityGetCommunity200ResponseChainNodeCosmosGovVersionEnum;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  health?: QueryCommunityGetCommunity200ResponseChainNodeHealthEnum;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseChainNodeContractsInner>}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  contracts?: Array<QueryCommunityGetCommunity200ResponseChainNodeContractsInner>;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  block_explorer?: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseChainNode
   */
  max_ce_block_range?: number | null;
}

export const QueryCommunityGetCommunity200ResponseChainNodeBalanceTypeEnum = {
  Terra: 'terra',
  Ethereum: 'ethereum',
  Solana: 'solana',
  Cosmos: 'cosmos',
  Near: 'near',
  Substrate: 'substrate',
} as const;

export type QueryCommunityGetCommunity200ResponseChainNodeBalanceTypeEnum =
  typeof QueryCommunityGetCommunity200ResponseChainNodeBalanceTypeEnum[keyof typeof QueryCommunityGetCommunity200ResponseChainNodeBalanceTypeEnum];
export const QueryCommunityGetCommunity200ResponseChainNodeCosmosGovVersionEnum =
  {
    V1: 'v1',
    V1beta1: 'v1beta1',
    V1beta1AttemptFailed: 'v1beta1-attempt-failed',
    V1AttemptFailed: 'v1-attempt-failed',
  } as const;

export type QueryCommunityGetCommunity200ResponseChainNodeCosmosGovVersionEnum =
  typeof QueryCommunityGetCommunity200ResponseChainNodeCosmosGovVersionEnum[keyof typeof QueryCommunityGetCommunity200ResponseChainNodeCosmosGovVersionEnum];
export const QueryCommunityGetCommunity200ResponseChainNodeHealthEnum = {
  Failed: 'failed',
  Healthy: 'healthy',
} as const;

export type QueryCommunityGetCommunity200ResponseChainNodeHealthEnum =
  typeof QueryCommunityGetCommunity200ResponseChainNodeHealthEnum[keyof typeof QueryCommunityGetCommunity200ResponseChainNodeHealthEnum];

/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseChainNodeContractsInner
 */
export interface QueryCommunityGetCommunity200ResponseChainNodeContractsInner {
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseChainNodeContractsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNodeContractsInner
   */
  address: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseChainNodeContractsInner
   */
  chain_node_id: number;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseChainNodeContractsInner
   */
  abi_id?: number | null;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseChainNodeContractsInner
   */
  decimals?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNodeContractsInner
   */
  token_name?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNodeContractsInner
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNodeContractsInner
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNodeContractsInner
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNodeContractsInner
   */
  updated_at: string;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200ResponseChainNodeContractsInner
   */
  is_factory?: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseChainNodeContractsInner
   */
  nickname?: string;
}
/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseCommunityStakesInner
 */
export interface QueryCommunityGetCommunity200ResponseCommunityStakesInner {
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInner
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInner
   */
  community_id: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInner
   */
  stake_id?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInner
   */
  stake_token?: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInner
   */
  vote_weight?: number;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInner
   */
  stake_enabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInner
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInner
   */
  updated_at?: string;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner>}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInner
   */
  StakeTransactions?: Array<QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner>;
}
/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
 */
export interface QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  transaction_hash: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  community_id: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  stake_id?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  address: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  stake_amount: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  stake_price?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  stake_direction: QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInnerStakeDirectionEnum;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  timestamp: number;
}

export const QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInnerStakeDirectionEnum =
  {
    Buy: 'buy',
    Sell: 'sell',
  } as const;

export type QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInnerStakeDirectionEnum =
  typeof QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInnerStakeDirectionEnum[keyof typeof QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInnerStakeDirectionEnum];

/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseCommunityTagsInner
 */
export interface QueryCommunityGetCommunity200ResponseCommunityTagsInner {
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityTagsInner
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseCommunityTagsInner
   */
  name: string;
}
/**
 * On-Chain Contest Manager
 * @export
 * @interface QueryCommunityGetCommunity200ResponseContestManagersInner
 */
export interface QueryCommunityGetCommunity200ResponseContestManagersInner {
  /**
   * On-Chain contest manager address
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  contest_address: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  image_url?: string;
  /**
   * Provided by admin on creation when stake funds are not used
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  funding_token_address?: string | null;
  /**
   * Percentage of pool used for prizes in recurring contests
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  prize_percentage?: number | null;
  /**
   * Sorted array of percentages for prize, from first to last
   * @type {Array<number>}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  payout_structure: Array<number>;
  /**
   * Recurring contest interval, 0 when one-off
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  interval: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  ticker?: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  decimals?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  created_at: string;
  /**
   * Flags when contest policy is cancelled by admin
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  cancelled?: boolean | null;
  /**
   * Flags when the one-off contest has ended and rollover was completed
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  ended?: boolean | null;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseTopicsInner>}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  topics?: Array<QueryCommunityGetCommunity200ResponseTopicsInner>;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInner>}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInner
   */
  contests?: Array<QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInner>;
}
/**
 * On-Chain contest instance
 * @export
 * @interface QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInner
 */
export interface QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInner {
  /**
   * On-Chain contest manager address
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  contest_address: string;
  /**
   * On-Chain contest id, 0 when one-off
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  contest_id: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  start_time: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  end_time: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  score_updated_at?: string | null;
  /**
   * Contest score, sorted from first to last
   * @type {Array<QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner>}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  score?: Array<QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner> | null;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner>}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  actions?: Array<QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner> | null;
}
/**
 * On-Chain content related actions on contest instance
 * @export
 * @interface QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
 */
export interface QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner {
  /**
   * On-Chain contest manager address
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  contest_address: string;
  /**
   * On-Chain contest id, 0 when one-off
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  contest_id: number;
  /**
   * On-Chain content id, 0 when adding
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  content_id: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  actor_address: string;
  /**
   * Type of content action
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  action: QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInnerActionEnum;
  /**
   * Content url
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  content_url?: string | null;
  /**
   * Thread id mapped from content url
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  thread_id?: number | null;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  thread_title?: string | null;
  /**
   * Voting power of address when action was recorded
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  voting_power: number;
  /**
   * Date-time when action was recorded
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  created_at: string;
}

export const QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInnerActionEnum =
  {
    Added: 'added',
    Upvoted: 'upvoted',
  } as const;

export type QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInnerActionEnum =
  typeof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInnerActionEnum[keyof typeof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInnerActionEnum];

/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner
 */
export interface QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner
   */
  creator_address: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner
   */
  content_id: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner
   */
  votes: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner
   */
  prize: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner
   */
  tickerPrize?: number;
}
/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseGroupsInner
 */
export interface QueryCommunityGetCommunity200ResponseGroupsInner {
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInner
   */
  community_id: string;
  /**
   *
   * @type {QueryCommunityGetCommunity200ResponseGroupsInnerMetadata}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInner
   */
  metadata: QueryCommunityGetCommunity200ResponseGroupsInnerMetadata;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInner>}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInner
   */
  requirements: Array<QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInner>;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInner
   */
  is_system_managed?: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInner
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInner
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseGroupsInnerMetadata
 */
export interface QueryCommunityGetCommunity200ResponseGroupsInnerMetadata {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerMetadata
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerMetadata
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerMetadata
   */
  required_requirements?: number;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerMetadata
   */
  membership_ttl?: number;
}
/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInner
 */
export interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInner {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInner
   */
  rule: QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerRuleEnum;
  /**
   *
   * @type {QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInner
   */
  data: QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data;
}

export const QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerRuleEnum =
  {
    Allow: 'allow',
  } as const;

export type QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerRuleEnum =
  typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerRuleEnum[keyof typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerRuleEnum];

/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf
 */
export interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf
   */
  rule: QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfRuleEnum;
  /**
   *
   * @type {QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfData}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf
   */
  data: QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfData;
}

export const QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfRuleEnum =
  {
    Threshold: 'threshold',
  } as const;

export type QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfRuleEnum =
  typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfRuleEnum[keyof typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfRuleEnum];

/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1
 */
export interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1 {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1
   */
  rule: QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1RuleEnum;
  /**
   *
   * @type {QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1
   */
  data: QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data;
}

export const QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1RuleEnum =
  {
    Allow: 'allow',
  } as const;

export type QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1RuleEnum =
  typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1RuleEnum[keyof typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1RuleEnum];

/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data
 */
export interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data {
  /**
   *
   * @type {Array<string>}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data
   */
  allow: Array<string>;
}
/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfData
 */
export interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfData {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfData
   */
  threshold: string;
  /**
   *
   * @type {QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfData
   */
  source: QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource;
}
/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
 */
export interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
   */
  source_type: QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceSourceTypeEnum;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
   */
  evm_chain_id: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
   */
  contract_address: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
   */
  token_id?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
   */
  cosmos_chain_id: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
   */
  token_symbol: string;
}

export const QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceSourceTypeEnum =
  {
    Cw721: 'cw721',
    Cw20: 'cw20',
  } as const;

export type QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceSourceTypeEnum =
  typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceSourceTypeEnum[keyof typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceSourceTypeEnum];

/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf
 */
export interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf
   */
  source_type: QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOfSourceTypeEnum;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf
   */
  evm_chain_id: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf
   */
  contract_address: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf
   */
  token_id?: string;
}

export const QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOfSourceTypeEnum =
  {
    Erc20: 'erc20',
    Erc721: 'erc721',
    Erc1155: 'erc1155',
    Spl: 'spl',
  } as const;

export type QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOfSourceTypeEnum =
  typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOfSourceTypeEnum[keyof typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOfSourceTypeEnum];

/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1
 */
export interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1 {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1
   */
  source_type: QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1SourceTypeEnum;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1
   */
  evm_chain_id: number;
}

export const QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1SourceTypeEnum =
  {
    EthNative: 'eth_native',
  } as const;

export type QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1SourceTypeEnum =
  typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1SourceTypeEnum[keyof typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1SourceTypeEnum];

/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2
 */
export interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2 {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2
   */
  source_type: QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2SourceTypeEnum;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2
   */
  cosmos_chain_id: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2
   */
  token_symbol: string;
}

export const QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2SourceTypeEnum =
  {
    CosmosNative: 'cosmos_native',
  } as const;

export type QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2SourceTypeEnum =
  typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2SourceTypeEnum[keyof typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2SourceTypeEnum];

/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3
 */
export interface QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3 {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3
   */
  source_type: QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3SourceTypeEnum;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3
   */
  cosmos_chain_id: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3
   */
  contract_address: string;
}

export const QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3SourceTypeEnum =
  {
    Cw721: 'cw721',
    Cw20: 'cw20',
  } as const;

export type QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3SourceTypeEnum =
  typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3SourceTypeEnum[keyof typeof QueryCommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3SourceTypeEnum];

/**
 *
 * @export
 * @interface QueryCommunityGetCommunity200ResponseTopicsInner
 */
export interface QueryCommunityGetCommunity200ResponseTopicsInner {
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseTopicsInner
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseTopicsInner
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseTopicsInner
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseTopicsInner
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseTopicsInner
   */
  telegram?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200ResponseTopicsInner
   */
  featured_in_sidebar?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetCommunity200ResponseTopicsInner
   */
  featured_in_new_post?: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseTopicsInner
   */
  default_offchain_template?: string | null;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetCommunity200ResponseTopicsInner
   */
  order?: number | null;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseTopicsInner
   */
  channel_id?: string | null;
  /**
   *
   * @type {Array<number>}
   * @memberof QueryCommunityGetCommunity200ResponseTopicsInner
   */
  group_ids?: Array<number>;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetCommunity200ResponseTopicsInner
   */
  default_offchain_template_backup?: string | null;
}
/**
 *
 * @export
 * @interface QueryCommunityGetMembers200Response
 */
export interface QueryCommunityGetMembers200Response {
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetMembers200Response
   */
  limit: number;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetMembers200Response
   */
  page: number;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetMembers200Response
   */
  totalPages: number;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetMembers200Response
   */
  totalResults: number;
  /**
   *
   * @type {Array<QueryCommunityGetMembers200ResponseResultsInner>}
   * @memberof QueryCommunityGetMembers200Response
   */
  results: Array<QueryCommunityGetMembers200ResponseResultsInner>;
}
/**
 *
 * @export
 * @interface QueryCommunityGetMembers200ResponseResultsInner
 */
export interface QueryCommunityGetMembers200ResponseResultsInner {
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetMembers200ResponseResultsInner
   */
  user_id: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetMembers200ResponseResultsInner
   */
  profile_name?: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetMembers200ResponseResultsInner
   */
  avatar_url?: string | null;
  /**
   *
   * @type {Array<QueryCommunityGetMembers200ResponseResultsInnerAddressesInner>}
   * @memberof QueryCommunityGetMembers200ResponseResultsInner
   */
  addresses: Array<QueryCommunityGetMembers200ResponseResultsInnerAddressesInner>;
  /**
   *
   * @type {Array<number>}
   * @memberof QueryCommunityGetMembers200ResponseResultsInner
   */
  group_ids: Array<number>;
  /**
   * string or date
   * @type {any}
   * @memberof QueryCommunityGetMembers200ResponseResultsInner
   */
  last_active?: any | null;
}
/**
 *
 * @export
 * @interface QueryCommunityGetMembers200ResponseResultsInnerAddressesInner
 */
export interface QueryCommunityGetMembers200ResponseResultsInnerAddressesInner {
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetMembers200ResponseResultsInnerAddressesInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetMembers200ResponseResultsInnerAddressesInner
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetMembers200ResponseResultsInnerAddressesInner
   */
  address: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetMembers200ResponseResultsInnerAddressesInner
   */
  stake_balance?: number | null;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetMembers200ResponseResultsInnerAddressesInner
   */
  role: string;
}
/**
 *
 * @export
 * @interface QueryCommunityGetMembersMembershipsParameter
 */
export interface QueryCommunityGetMembersMembershipsParameter {}
/**
 *
 * @export
 * @interface QueryCommunityGetStake200Response
 */
export interface QueryCommunityGetStake200Response {
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetStake200Response
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStake200Response
   */
  community_id: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetStake200Response
   */
  stake_id?: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStake200Response
   */
  stake_token?: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetStake200Response
   */
  vote_weight?: number;
  /**
   *
   * @type {boolean}
   * @memberof QueryCommunityGetStake200Response
   */
  stake_enabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStake200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStake200Response
   */
  updated_at?: string;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner>}
   * @memberof QueryCommunityGetStake200Response
   */
  StakeTransactions?: Array<QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner>;
}
/**
 *
 * @export
 * @interface QueryCommunityGetStakeHistoricalPrice200ResponseInner
 */
export interface QueryCommunityGetStakeHistoricalPrice200ResponseInner {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStakeHistoricalPrice200ResponseInner
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStakeHistoricalPrice200ResponseInner
   */
  old_price?: string | null;
}
/**
 *
 * @export
 * @interface QueryCommunityGetStakeTransaction200ResponseInner
 */
export interface QueryCommunityGetStakeTransaction200ResponseInner {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStakeTransaction200ResponseInner
   */
  transaction_hash: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStakeTransaction200ResponseInner
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStakeTransaction200ResponseInner
   */
  stake_price: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetStakeTransaction200ResponseInner
   */
  stake_amount: number;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetStakeTransaction200ResponseInner
   */
  vote_weight: number;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetStakeTransaction200ResponseInner
   */
  timestamp: number;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStakeTransaction200ResponseInner
   */
  stake_direction: string;
  /**
   *
   * @type {QueryCommunityGetStakeTransaction200ResponseInnerCommunity}
   * @memberof QueryCommunityGetStakeTransaction200ResponseInner
   */
  community: QueryCommunityGetStakeTransaction200ResponseInnerCommunity;
}
/**
 *
 * @export
 * @interface QueryCommunityGetStakeTransaction200ResponseInnerCommunity
 */
export interface QueryCommunityGetStakeTransaction200ResponseInnerCommunity {
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStakeTransaction200ResponseInnerCommunity
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStakeTransaction200ResponseInnerCommunity
   */
  default_symbol?: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStakeTransaction200ResponseInnerCommunity
   */
  icon_url?: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryCommunityGetStakeTransaction200ResponseInnerCommunity
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof QueryCommunityGetStakeTransaction200ResponseInnerCommunity
   */
  chain_node_id?: number | null;
}
/**
 * On-Chain Contest Manager
 * @export
 * @interface QueryContestGetAllContests200ResponseInner
 */
export interface QueryContestGetAllContests200ResponseInner {
  /**
   * On-Chain contest manager address
   * @type {string}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  contest_address: string;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  image_url?: string;
  /**
   * Provided by admin on creation when stake funds are not used
   * @type {string}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  funding_token_address?: string | null;
  /**
   * Percentage of pool used for prizes in recurring contests
   * @type {number}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  prize_percentage?: number | null;
  /**
   * Sorted array of percentages for prize, from first to last
   * @type {Array<number>}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  payout_structure: Array<number>;
  /**
   * Recurring contest interval, 0 when one-off
   * @type {number}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  interval: number;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  ticker?: string;
  /**
   *
   * @type {number}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  decimals?: number;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  created_at: string;
  /**
   * Flags when contest policy is cancelled by admin
   * @type {boolean}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  cancelled?: boolean | null;
  /**
   * Flags when the one-off contest has ended and rollover was completed
   * @type {boolean}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  ended?: boolean | null;
  /**
   *
   * @type {Array<QueryContestGetAllContests200ResponseInnerTopicsInner>}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  topics: Array<QueryContestGetAllContests200ResponseInnerTopicsInner>;
  /**
   *
   * @type {Array<QueryContestGetAllContests200ResponseInnerContestsInner>}
   * @memberof QueryContestGetAllContests200ResponseInner
   */
  contests: Array<QueryContestGetAllContests200ResponseInnerContestsInner>;
}
/**
 * On-Chain contest instance
 * @export
 * @interface QueryContestGetAllContests200ResponseInnerContestsInner
 */
export interface QueryContestGetAllContests200ResponseInnerContestsInner {
  /**
   * On-Chain contest id, 0 when one-off
   * @type {number}
   * @memberof QueryContestGetAllContests200ResponseInnerContestsInner
   */
  contest_id: number;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetAllContests200ResponseInnerContestsInner
   */
  start_time: string;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetAllContests200ResponseInnerContestsInner
   */
  end_time: string;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetAllContests200ResponseInnerContestsInner
   */
  score_updated_at?: string | null;
  /**
   * Contest score, sorted from first to last
   * @type {Array<QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner>}
   * @memberof QueryContestGetAllContests200ResponseInnerContestsInner
   */
  score?: Array<QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner> | null;
  /**
   *
   * @type {Array<QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner>}
   * @memberof QueryContestGetAllContests200ResponseInnerContestsInner
   */
  actions?: Array<QueryCommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner> | null;
}
/**
 *
 * @export
 * @interface QueryContestGetAllContests200ResponseInnerTopicsInner
 */
export interface QueryContestGetAllContests200ResponseInnerTopicsInner {
  /**
   *
   * @type {number}
   * @memberof QueryContestGetAllContests200ResponseInnerTopicsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetAllContests200ResponseInnerTopicsInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface QueryContestGetContestLog200ResponseInner
 */
export interface QueryContestGetContestLog200ResponseInner {
  /**
   *
   * @type {string}
   * @memberof QueryContestGetContestLog200ResponseInner
   */
  event_name: string;
  /**
   *
   * @type {object}
   * @memberof QueryContestGetContestLog200ResponseInner
   */
  event_payload: object;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetContestLog200ResponseInner
   */
  contest_address: string;
  /**
   *
   * @type {number}
   * @memberof QueryContestGetContestLog200ResponseInner
   */
  contest_id: number;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetContestLog200ResponseInner
   */
  action?: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetContestLog200ResponseInner
   */
  actor_address?: string | null;
  /**
   *
   * @type {number}
   * @memberof QueryContestGetContestLog200ResponseInner
   */
  voting_power?: number | null;
  /**
   *
   * @type {number}
   * @memberof QueryContestGetContestLog200ResponseInner
   */
  thread_id?: number | null;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetContestLog200ResponseInner
   */
  thread_title?: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryContestGetContestLog200ResponseInner
   */
  created_at: string;
}
/**
 *
 * @export
 * @interface QueryFeedGetChainActivity200ResponseInner
 */
export interface QueryFeedGetChainActivity200ResponseInner {
  /**
   *
   * @type {string}
   * @memberof QueryFeedGetChainActivity200ResponseInner
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof QueryFeedGetChainActivity200ResponseInner
   */
  network: string;
  /**
   *
   * @type {number}
   * @memberof QueryFeedGetChainActivity200ResponseInner
   */
  block_number: number;
  /**
   *
   * @type {QueryFeedGetChainActivity200ResponseInnerEventData}
   * @memberof QueryFeedGetChainActivity200ResponseInner
   */
  event_data: QueryFeedGetChainActivity200ResponseInnerEventData;
}
/**
 *
 * @export
 * @interface QueryFeedGetChainActivity200ResponseInnerEventData
 */
export interface QueryFeedGetChainActivity200ResponseInnerEventData {
  /**
   *
   * @type {string}
   * @memberof QueryFeedGetChainActivity200ResponseInnerEventData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof QueryFeedGetChainActivity200ResponseInnerEventData
   */
  kind: string;
}
/**
 *
 * @export
 * @interface QueryFeedGetUserActivity200ResponseInner
 */
export interface QueryFeedGetUserActivity200ResponseInner {
  /**
   *
   * @type {number}
   * @memberof QueryFeedGetUserActivity200ResponseInner
   */
  thread_id: number;
  /**
   *
   * @type {string}
   * @memberof QueryFeedGetUserActivity200ResponseInner
   */
  last_activity?: string;
  /**
   *
   * @type {string}
   * @memberof QueryFeedGetUserActivity200ResponseInner
   */
  notification_data: string;
  /**
   *
   * @type {string}
   * @memberof QueryFeedGetUserActivity200ResponseInner
   */
  category_id: string;
  /**
   *
   * @type {number}
   * @memberof QueryFeedGetUserActivity200ResponseInner
   */
  comment_count: number;
  /**
   *
   * @type {Array<QueryFeedGetUserActivity200ResponseInnerCommentersInner>}
   * @memberof QueryFeedGetUserActivity200ResponseInner
   */
  commenters: Array<QueryFeedGetUserActivity200ResponseInnerCommentersInner>;
}
/**
 *
 * @export
 * @interface QueryFeedGetUserActivity200ResponseInnerCommentersInner
 */
export interface QueryFeedGetUserActivity200ResponseInnerCommentersInner {
  /**
   *
   * @type {Array<QueryThreadGetBulkThreads200ResponseThreadsInnerAddress>}
   * @memberof QueryFeedGetUserActivity200ResponseInnerCommentersInner
   */
  Addresses: Array<QueryThreadGetBulkThreads200ResponseThreadsInnerAddress>;
}
/**
 *
 * @export
 * @interface QuerySubscriptionGetSubscriptionPreferences200Response
 */
export interface QuerySubscriptionGetSubscriptionPreferences200Response {
  /**
   *
   * @type {number}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200Response
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200Response
   */
  user_id: number;
  /**
   *
   * @type {boolean}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200Response
   */
  email_notifications_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200Response
   */
  digest_email_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200Response
   */
  recap_email_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200Response
   */
  mobile_push_notifications_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200Response
   */
  mobile_push_discussion_activity_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200Response
   */
  mobile_push_admin_alerts_enabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200Response
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf
 */
export interface QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf {
  /**
   *
   * @type {number}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  user_id: number;
  /**
   *
   * @type {boolean}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  email_notifications_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  digest_email_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  recap_email_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  mobile_push_notifications_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  mobile_push_discussion_activity_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  mobile_push_admin_alerts_enabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface QueryThreadGetBulkThreads200Response
 */
export interface QueryThreadGetBulkThreads200Response {
  /**
   *
   * @type {number}
   * @memberof QueryThreadGetBulkThreads200Response
   */
  limit: number;
  /**
   *
   * @type {number}
   * @memberof QueryThreadGetBulkThreads200Response
   */
  numVotingThreads: number;
  /**
   *
   * @type {number}
   * @memberof QueryThreadGetBulkThreads200Response
   */
  cursor: number;
  /**
   *
   * @type {Array<QueryThreadGetBulkThreads200ResponseThreadsInner>}
   * @memberof QueryThreadGetBulkThreads200Response
   */
  threads: Array<QueryThreadGetBulkThreads200ResponseThreadsInner>;
}
/**
 *
 * @export
 * @interface QueryThreadGetBulkThreads200ResponseThreadsInner
 */
export interface QueryThreadGetBulkThreads200ResponseThreadsInner {
  /**
   *
   * @type {number}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  url: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  body: string;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  last_edited?: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  kind: string;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  stage: string;
  /**
   *
   * @type {boolean}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  read_only: boolean;
  /**
   *
   * @type {QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  discord_meta?: QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta | null;
  /**
   *
   * @type {boolean}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  pinned: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  chain: string;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  updated_at: string;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  locked_at?: string | null;
  /**
   *
   * @type {Array<QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInner>}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  links?: Array<QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInner> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  collaborators: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  has_poll?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  last_commented_on?: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  plaintext?: string | null;
  /**
   *
   * @type {QueryThreadGetBulkThreads200ResponseThreadsInnerAddress}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  Address: QueryThreadGetBulkThreads200ResponseThreadsInnerAddress;
  /**
   *
   * @type {number}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  numberOfComments: number;
  /**
   *
   * @type {Array<string>}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  reactionIds: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  reactionTimestamps: Array<string>;
  /**
   *
   * @type {Array<number>}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  reactionWeights: Array<number>;
  /**
   *
   * @type {number}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  reaction_weights_sum: number;
  /**
   *
   * @type {Array<string>}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  addressesReacted: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  reactedProfileName?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  reactedProfileAvatarUrl?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  reactedAddressLastActive?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  reactionType: Array<string>;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  marked_as_spam_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  archived_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  latest_activity?: string | null;
  /**
   *
   * @type {QueryThreadGetBulkThreads200ResponseThreadsInnerTopic}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  topic?: QueryThreadGetBulkThreads200ResponseThreadsInnerTopic;
  /**
   *
   * @type {number}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  user_id: number;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  avatar_url: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  address_last_active: string | null;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInner
   */
  profile_name: string | null;
}
/**
 *
 * @export
 * @interface QueryThreadGetBulkThreads200ResponseThreadsInnerAddress
 */
export interface QueryThreadGetBulkThreads200ResponseThreadsInnerAddress {
  /**
   *
   * @type {number}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerAddress
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerAddress
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerAddress
   */
  community_id: string;
}
/**
 *
 * @export
 * @interface QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta
 */
export interface QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta {
  /**
   *
   * @type {QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMetaUser}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta
   */
  user: QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMetaUser;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta
   */
  channel_id: string;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta
   */
  message_id: string;
}
/**
 *
 * @export
 * @interface QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMetaUser
 */
export interface QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMetaUser {
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMetaUser
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerDiscordMetaUser
   */
  username: string;
}
/**
 *
 * @export
 * @interface QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInner
 */
export interface QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInner {
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInner
   */
  source: QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInnerSourceEnum;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInner
   */
  identifier: string;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInner
   */
  title?: string | null;
}

export const QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInnerSourceEnum =
  {
    Snapshot: 'snapshot',
    Proposal: 'proposal',
    Thread: 'thread',
    Web: 'web',
    Template: 'template',
  } as const;

export type QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInnerSourceEnum =
  typeof QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInnerSourceEnum[keyof typeof QueryThreadGetBulkThreads200ResponseThreadsInnerLinksInnerSourceEnum];

/**
 *
 * @export
 * @interface QueryThreadGetBulkThreads200ResponseThreadsInnerTopic
 */
export interface QueryThreadGetBulkThreads200ResponseThreadsInnerTopic {
  /**
   *
   * @type {number}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerTopic
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerTopic
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerTopic
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerTopic
   */
  chainId: string;
  /**
   *
   * @type {string}
   * @memberof QueryThreadGetBulkThreads200ResponseThreadsInnerTopic
   */
  telegram: string;
}

/**
 * CommunityApi - axios parameter creator
 * @export
 */
export const CommunityApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationCommunityCreateGroupRequest} mutationCommunityCreateGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationCommunityCreateGroup: async (
      addressId: string,
      id: string,
      mutationCommunityCreateGroupRequest: MutationCommunityCreateGroupRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists('mutationCommunityCreateGroup', 'addressId', addressId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('mutationCommunityCreateGroup', 'id', id);
      // verify required parameter 'mutationCommunityCreateGroupRequest' is not null or undefined
      assertParamExists(
        'mutationCommunityCreateGroup',
        'mutationCommunityCreateGroupRequest',
        mutationCommunityCreateGroupRequest,
      );
      const localVarPath = `/community/{id}/CreateGroup`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationCommunityCreateGroupRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationCommunityCreateStakeTransactionRequest} mutationCommunityCreateStakeTransactionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationCommunityCreateStakeTransaction: async (
      addressId: string,
      id: string,
      mutationCommunityCreateStakeTransactionRequest: MutationCommunityCreateStakeTransactionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'mutationCommunityCreateStakeTransaction',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('mutationCommunityCreateStakeTransaction', 'id', id);
      // verify required parameter 'mutationCommunityCreateStakeTransactionRequest' is not null or undefined
      assertParamExists(
        'mutationCommunityCreateStakeTransaction',
        'mutationCommunityCreateStakeTransactionRequest',
        mutationCommunityCreateStakeTransactionRequest,
      );
      const localVarPath = `/community/{id}/CreateStakeTransaction`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationCommunityCreateStakeTransactionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationCommunitySetStakeRequest} mutationCommunitySetStakeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationCommunitySetStake: async (
      addressId: string,
      id: string,
      mutationCommunitySetStakeRequest: MutationCommunitySetStakeRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists('mutationCommunitySetStake', 'addressId', addressId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('mutationCommunitySetStake', 'id', id);
      // verify required parameter 'mutationCommunitySetStakeRequest' is not null or undefined
      assertParamExists(
        'mutationCommunitySetStake',
        'mutationCommunitySetStakeRequest',
        mutationCommunitySetStakeRequest,
      );
      const localVarPath = `/community/{id}/SetCommunityStake`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationCommunitySetStakeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner} mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationContestCancelContestMetadata: async (
      addressId: string,
      id: string,
      mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner: MutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'mutationContestCancelContestMetadata',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('mutationContestCancelContestMetadata', 'id', id);
      // verify required parameter 'mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner' is not null or undefined
      assertParamExists(
        'mutationContestCancelContestMetadata',
        'mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner',
        mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner,
      );
      const localVarPath =
        `/community/{id}/CancelContestManagerMetadata`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(id)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationContestCreateContestMetadataRequest} mutationContestCreateContestMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationContestCreateContestMetadata: async (
      addressId: string,
      id: string,
      mutationContestCreateContestMetadataRequest: MutationContestCreateContestMetadataRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'mutationContestCreateContestMetadata',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('mutationContestCreateContestMetadata', 'id', id);
      // verify required parameter 'mutationContestCreateContestMetadataRequest' is not null or undefined
      assertParamExists(
        'mutationContestCreateContestMetadata',
        'mutationContestCreateContestMetadataRequest',
        mutationContestCreateContestMetadataRequest,
      );
      const localVarPath =
        `/community/{id}/CreateContestManagerMetadata`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(id)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationContestCreateContestMetadataRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationContestUpdateContestMetadataRequest} mutationContestUpdateContestMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationContestUpdateContestMetadata: async (
      addressId: string,
      id: string,
      mutationContestUpdateContestMetadataRequest: MutationContestUpdateContestMetadataRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'mutationContestUpdateContestMetadata',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('mutationContestUpdateContestMetadata', 'id', id);
      // verify required parameter 'mutationContestUpdateContestMetadataRequest' is not null or undefined
      assertParamExists(
        'mutationContestUpdateContestMetadata',
        'mutationContestUpdateContestMetadataRequest',
        mutationContestUpdateContestMetadataRequest,
      );
      const localVarPath =
        `/community/{id}/UpdateContestManagerMetadata`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(id)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationContestUpdateContestMetadataRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CommunityApi - functional programming interface
 * @export
 */
export const CommunityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CommunityApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationCommunityCreateGroupRequest} mutationCommunityCreateGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationCommunityCreateGroup(
      addressId: string,
      id: string,
      mutationCommunityCreateGroupRequest: MutationCommunityCreateGroupRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MutationCommunitySetStake200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationCommunityCreateGroup(
          addressId,
          id,
          mutationCommunityCreateGroupRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CommunityApi.mutationCommunityCreateGroup']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationCommunityCreateStakeTransactionRequest} mutationCommunityCreateStakeTransactionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationCommunityCreateStakeTransaction(
      addressId: string,
      id: string,
      mutationCommunityCreateStakeTransactionRequest: MutationCommunityCreateStakeTransactionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationCommunityCreateStakeTransaction(
          addressId,
          id,
          mutationCommunityCreateStakeTransactionRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'CommunityApi.mutationCommunityCreateStakeTransaction'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationCommunitySetStakeRequest} mutationCommunitySetStakeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationCommunitySetStake(
      addressId: string,
      id: string,
      mutationCommunitySetStakeRequest: MutationCommunitySetStakeRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MutationCommunitySetStake200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationCommunitySetStake(
          addressId,
          id,
          mutationCommunitySetStakeRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CommunityApi.mutationCommunitySetStake']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner} mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationContestCancelContestMetadata(
      addressId: string,
      id: string,
      mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner: MutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MutationContestCreateContestMetadata200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationContestCancelContestMetadata(
          addressId,
          id,
          mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'CommunityApi.mutationContestCancelContestMetadata'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationContestCreateContestMetadataRequest} mutationContestCreateContestMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationContestCreateContestMetadata(
      addressId: string,
      id: string,
      mutationContestCreateContestMetadataRequest: MutationContestCreateContestMetadataRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MutationContestCreateContestMetadata200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationContestCreateContestMetadata(
          addressId,
          id,
          mutationContestCreateContestMetadataRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'CommunityApi.mutationContestCreateContestMetadata'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationContestUpdateContestMetadataRequest} mutationContestUpdateContestMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationContestUpdateContestMetadata(
      addressId: string,
      id: string,
      mutationContestUpdateContestMetadataRequest: MutationContestUpdateContestMetadataRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MutationContestCreateContestMetadata200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationContestUpdateContestMetadata(
          addressId,
          id,
          mutationContestUpdateContestMetadataRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'CommunityApi.mutationContestUpdateContestMetadata'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CommunityApi - factory interface
 * @export
 */
export const CommunityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CommunityApiFp(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationCommunityCreateGroupRequest} mutationCommunityCreateGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationCommunityCreateGroup(
      addressId: string,
      id: string,
      mutationCommunityCreateGroupRequest: MutationCommunityCreateGroupRequest,
      options?: any,
    ): AxiosPromise<MutationCommunitySetStake200Response> {
      return localVarFp
        .mutationCommunityCreateGroup(
          addressId,
          id,
          mutationCommunityCreateGroupRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationCommunityCreateStakeTransactionRequest} mutationCommunityCreateStakeTransactionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationCommunityCreateStakeTransaction(
      addressId: string,
      id: string,
      mutationCommunityCreateStakeTransactionRequest: MutationCommunityCreateStakeTransactionRequest,
      options?: any,
    ): AxiosPromise<QueryCommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner> {
      return localVarFp
        .mutationCommunityCreateStakeTransaction(
          addressId,
          id,
          mutationCommunityCreateStakeTransactionRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationCommunitySetStakeRequest} mutationCommunitySetStakeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationCommunitySetStake(
      addressId: string,
      id: string,
      mutationCommunitySetStakeRequest: MutationCommunitySetStakeRequest,
      options?: any,
    ): AxiosPromise<MutationCommunitySetStake200Response> {
      return localVarFp
        .mutationCommunitySetStake(
          addressId,
          id,
          mutationCommunitySetStakeRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner} mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationContestCancelContestMetadata(
      addressId: string,
      id: string,
      mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner: MutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner,
      options?: any,
    ): AxiosPromise<MutationContestCreateContestMetadata200Response> {
      return localVarFp
        .mutationContestCancelContestMetadata(
          addressId,
          id,
          mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationContestCreateContestMetadataRequest} mutationContestCreateContestMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationContestCreateContestMetadata(
      addressId: string,
      id: string,
      mutationContestCreateContestMetadataRequest: MutationContestCreateContestMetadataRequest,
      options?: any,
    ): AxiosPromise<MutationContestCreateContestMetadata200Response> {
      return localVarFp
        .mutationContestCreateContestMetadata(
          addressId,
          id,
          mutationContestCreateContestMetadataRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {MutationContestUpdateContestMetadataRequest} mutationContestUpdateContestMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationContestUpdateContestMetadata(
      addressId: string,
      id: string,
      mutationContestUpdateContestMetadataRequest: MutationContestUpdateContestMetadataRequest,
      options?: any,
    ): AxiosPromise<MutationContestCreateContestMetadata200Response> {
      return localVarFp
        .mutationContestUpdateContestMetadata(
          addressId,
          id,
          mutationContestUpdateContestMetadataRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CommunityApi - object-oriented interface
 * @export
 * @class CommunityApi
 * @extends {BaseAPI}
 */
export class CommunityApi extends BaseAPI {
  /**
   *
   * @param {string} addressId
   * @param {string} id
   * @param {MutationCommunityCreateGroupRequest} mutationCommunityCreateGroupRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunityApi
   */
  public mutationCommunityCreateGroup(
    addressId: string,
    id: string,
    mutationCommunityCreateGroupRequest: MutationCommunityCreateGroupRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CommunityApiFp(this.configuration)
      .mutationCommunityCreateGroup(
        addressId,
        id,
        mutationCommunityCreateGroupRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {string} id
   * @param {MutationCommunityCreateStakeTransactionRequest} mutationCommunityCreateStakeTransactionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunityApi
   */
  public mutationCommunityCreateStakeTransaction(
    addressId: string,
    id: string,
    mutationCommunityCreateStakeTransactionRequest: MutationCommunityCreateStakeTransactionRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CommunityApiFp(this.configuration)
      .mutationCommunityCreateStakeTransaction(
        addressId,
        id,
        mutationCommunityCreateStakeTransactionRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {string} id
   * @param {MutationCommunitySetStakeRequest} mutationCommunitySetStakeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunityApi
   */
  public mutationCommunitySetStake(
    addressId: string,
    id: string,
    mutationCommunitySetStakeRequest: MutationCommunitySetStakeRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CommunityApiFp(this.configuration)
      .mutationCommunitySetStake(
        addressId,
        id,
        mutationCommunitySetStakeRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {string} id
   * @param {MutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner} mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunityApi
   */
  public mutationContestCancelContestMetadata(
    addressId: string,
    id: string,
    mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner: MutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner,
    options?: RawAxiosRequestConfig,
  ) {
    return CommunityApiFp(this.configuration)
      .mutationContestCancelContestMetadata(
        addressId,
        id,
        mutationIntegrationsAnalyticsRequestThreadCreatedContestManagersInner,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {string} id
   * @param {MutationContestCreateContestMetadataRequest} mutationContestCreateContestMetadataRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunityApi
   */
  public mutationContestCreateContestMetadata(
    addressId: string,
    id: string,
    mutationContestCreateContestMetadataRequest: MutationContestCreateContestMetadataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CommunityApiFp(this.configuration)
      .mutationContestCreateContestMetadata(
        addressId,
        id,
        mutationContestCreateContestMetadataRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {string} id
   * @param {MutationContestUpdateContestMetadataRequest} mutationContestUpdateContestMetadataRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunityApi
   */
  public mutationContestUpdateContestMetadata(
    addressId: string,
    id: string,
    mutationContestUpdateContestMetadataRequest: MutationContestUpdateContestMetadataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CommunityApiFp(this.configuration)
      .mutationContestUpdateContestMetadata(
        addressId,
        id,
        mutationContestUpdateContestMetadataRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IntegrationApi - axios parameter creator
 * @export
 */
export const IntegrationApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {MutationIntegrationsAnalyticsRequest} mutationIntegrationsAnalyticsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationIntegrationsAnalytics: async (
      mutationIntegrationsAnalyticsRequest: MutationIntegrationsAnalyticsRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'mutationIntegrationsAnalyticsRequest' is not null or undefined
      assertParamExists(
        'mutationIntegrationsAnalytics',
        'mutationIntegrationsAnalyticsRequest',
        mutationIntegrationsAnalyticsRequest,
      );
      const localVarPath = `/integration/Analytics`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationIntegrationsAnalyticsRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IntegrationApi - functional programming interface
 * @export
 */
export const IntegrationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    IntegrationApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {MutationIntegrationsAnalyticsRequest} mutationIntegrationsAnalyticsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationIntegrationsAnalytics(
      mutationIntegrationsAnalyticsRequest: MutationIntegrationsAnalyticsRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationIntegrationsAnalytics(
          mutationIntegrationsAnalyticsRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['IntegrationApi.mutationIntegrationsAnalytics']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * IntegrationApi - factory interface
 * @export
 */
export const IntegrationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = IntegrationApiFp(configuration);
  return {
    /**
     *
     * @param {MutationIntegrationsAnalyticsRequest} mutationIntegrationsAnalyticsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationIntegrationsAnalytics(
      mutationIntegrationsAnalyticsRequest: MutationIntegrationsAnalyticsRequest,
      options?: any,
    ): AxiosPromise<object> {
      return localVarFp
        .mutationIntegrationsAnalytics(
          mutationIntegrationsAnalyticsRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IntegrationApi - object-oriented interface
 * @export
 * @class IntegrationApi
 * @extends {BaseAPI}
 */
export class IntegrationApi extends BaseAPI {
  /**
   *
   * @param {MutationIntegrationsAnalyticsRequest} mutationIntegrationsAnalyticsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IntegrationApi
   */
  public mutationIntegrationsAnalytics(
    mutationIntegrationsAnalyticsRequest: MutationIntegrationsAnalyticsRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return IntegrationApiFp(this.configuration)
      .mutationIntegrationsAnalytics(
        mutationIntegrationsAnalyticsRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LoadTestApi - axios parameter creator
 * @export
 */
export const LoadTestApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationLoadTestCreateJWTsRequest} mutationLoadTestCreateJWTsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationLoadTestCreateJWTs: async (
      addressId: string,
      id: number,
      mutationLoadTestCreateJWTsRequest: MutationLoadTestCreateJWTsRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists('mutationLoadTestCreateJWTs', 'addressId', addressId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('mutationLoadTestCreateJWTs', 'id', id);
      // verify required parameter 'mutationLoadTestCreateJWTsRequest' is not null or undefined
      assertParamExists(
        'mutationLoadTestCreateJWTs',
        'mutationLoadTestCreateJWTsRequest',
        mutationLoadTestCreateJWTsRequest,
      );
      const localVarPath = `/loadtest/{id}/CreateJWTs`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationLoadTestCreateJWTsRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LoadTestApi - functional programming interface
 * @export
 */
export const LoadTestApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LoadTestApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationLoadTestCreateJWTsRequest} mutationLoadTestCreateJWTsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationLoadTestCreateJWTs(
      addressId: string,
      id: number,
      mutationLoadTestCreateJWTsRequest: MutationLoadTestCreateJWTsRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationLoadTestCreateJWTs(
          addressId,
          id,
          mutationLoadTestCreateJWTsRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoadTestApi.mutationLoadTestCreateJWTs']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * LoadTestApi - factory interface
 * @export
 */
export const LoadTestApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LoadTestApiFp(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationLoadTestCreateJWTsRequest} mutationLoadTestCreateJWTsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationLoadTestCreateJWTs(
      addressId: string,
      id: number,
      mutationLoadTestCreateJWTsRequest: MutationLoadTestCreateJWTsRequest,
      options?: any,
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .mutationLoadTestCreateJWTs(
          addressId,
          id,
          mutationLoadTestCreateJWTsRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LoadTestApi - object-oriented interface
 * @export
 * @class LoadTestApi
 * @extends {BaseAPI}
 */
export class LoadTestApi extends BaseAPI {
  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {MutationLoadTestCreateJWTsRequest} mutationLoadTestCreateJWTsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoadTestApi
   */
  public mutationLoadTestCreateJWTs(
    addressId: string,
    id: number,
    mutationLoadTestCreateJWTsRequest: MutationLoadTestCreateJWTsRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LoadTestApiFp(this.configuration)
      .mutationLoadTestCreateJWTs(
        addressId,
        id,
        mutationLoadTestCreateJWTsRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} id
     * @param {string} [addressId]
     * @param {boolean} [includeNodeInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryCommunityGetCommunity: async (
      id: string,
      addressId?: string,
      includeNodeInfo?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('queryCommunityGetCommunity', 'id', id);
      const localVarPath = `/query/GetCommunity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (includeNodeInfo !== undefined) {
        localVarQueryParameter['include_node_info'] = includeNodeInfo;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {number | null} [limit]
     * @param {number | null} [cursor] required for tRPC useInfiniteQuery hook, equivalent to page number
     * @param {QueryCommunityGetMembersOrderByEnum} [orderBy]
     * @param {QueryCommunityGetMembersOrderDirectionEnum} [orderDirection]
     * @param {string} [search]
     * @param {boolean} [includeRoles]
     * @param {QueryCommunityGetMembersMembershipsParameter} [memberships]
     * @param {boolean} [includeGroupIds]
     * @param {boolean} [includeStakeBalances]
     * @param {string} [allowedAddresses]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryCommunityGetMembers: async (
      communityId: string,
      addressId?: string,
      limit?: number | null,
      cursor?: number | null,
      orderBy?: QueryCommunityGetMembersOrderByEnum,
      orderDirection?: QueryCommunityGetMembersOrderDirectionEnum,
      search?: string,
      includeRoles?: boolean,
      memberships?: QueryCommunityGetMembersMembershipsParameter,
      includeGroupIds?: boolean,
      includeStakeBalances?: boolean,
      allowedAddresses?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'communityId' is not null or undefined
      assertParamExists('queryCommunityGetMembers', 'communityId', communityId);
      const localVarPath = `/query/GetMembers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      if (orderDirection !== undefined) {
        localVarQueryParameter['order_direction'] = orderDirection;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      if (communityId !== undefined) {
        localVarQueryParameter['community_id'] = communityId;
      }

      if (includeRoles !== undefined) {
        localVarQueryParameter['include_roles'] = includeRoles;
      }

      if (memberships !== undefined) {
        for (const [key, value] of Object.entries(memberships)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (includeGroupIds !== undefined) {
        localVarQueryParameter['include_group_ids'] = includeGroupIds;
      }

      if (includeStakeBalances !== undefined) {
        localVarQueryParameter['include_stake_balances'] = includeStakeBalances;
      }

      if (allowedAddresses !== undefined) {
        localVarQueryParameter['allowedAddresses'] = allowedAddresses;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {number} [stakeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryCommunityGetStake: async (
      communityId: string,
      addressId?: string,
      stakeId?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'communityId' is not null or undefined
      assertParamExists('queryCommunityGetStake', 'communityId', communityId);
      const localVarPath = `/query/GetCommunityStake`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (communityId !== undefined) {
        localVarQueryParameter['community_id'] = communityId;
      }

      if (stakeId !== undefined) {
        localVarQueryParameter['stake_id'] = stakeId;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} pastDateEpoch
     * @param {string} [addressId]
     * @param {string} [communityId]
     * @param {number} [stakeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryCommunityGetStakeHistoricalPrice: async (
      pastDateEpoch: number,
      addressId?: string,
      communityId?: string,
      stakeId?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'pastDateEpoch' is not null or undefined
      assertParamExists(
        'queryCommunityGetStakeHistoricalPrice',
        'pastDateEpoch',
        pastDateEpoch,
      );
      const localVarPath = `/query/GetStakeHistoricalPrice`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (pastDateEpoch !== undefined) {
        localVarQueryParameter['past_date_epoch'] = pastDateEpoch;
      }

      if (communityId !== undefined) {
        localVarQueryParameter['community_id'] = communityId;
      }

      if (stakeId !== undefined) {
        localVarQueryParameter['stake_id'] = stakeId;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {string} [addresses]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryCommunityGetStakeTransaction: async (
      addressId?: string,
      addresses?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/query/GetStakeTransaction`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addresses !== undefined) {
        localVarQueryParameter['addresses'] = addresses;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {string} [contestAddress]
     * @param {number} [contestId]
     * @param {boolean} [running]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryContestGetAllContests: async (
      communityId: string,
      addressId?: string,
      contestAddress?: string,
      contestId?: number,
      running?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'communityId' is not null or undefined
      assertParamExists(
        'queryContestGetAllContests',
        'communityId',
        communityId,
      );
      const localVarPath = `/query/GetAllContests`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (communityId !== undefined) {
        localVarQueryParameter['community_id'] = communityId;
      }

      if (contestAddress !== undefined) {
        localVarQueryParameter['contest_address'] = contestAddress;
      }

      if (contestId !== undefined) {
        localVarQueryParameter['contest_id'] = contestId;
      }

      if (running !== undefined) {
        localVarQueryParameter['running'] = running;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} contestAddress
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryContestGetContestLog: async (
      contestAddress: string,
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'contestAddress' is not null or undefined
      assertParamExists(
        'queryContestGetContestLog',
        'contestAddress',
        contestAddress,
      );
      const localVarPath = `/query/GetContestLog`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (contestAddress !== undefined) {
        localVarQueryParameter['contest_address'] = contestAddress;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryFeedGetChainActivity: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/query/GetChainActivity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryFeedGetGlobalActivity: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/query/GetGlobalActivity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryFeedGetUserActivity: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/query/GetUserActivity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    querySubscriptionGetCommentSubscriptions: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/query/GetCommentSubscriptions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    querySubscriptionGetCommunityAlerts: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/query/GetCommunityAlerts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    querySubscriptionGetSubscriptionPreferences: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/query/GetSubscriptionPreferences`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    querySubscriptionGetThreadSubscriptions: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/query/GetThreadSubscriptions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {string} [fromDate]
     * @param {string} [toDate]
     * @param {boolean} [archived]
     * @param {boolean} [includePinnedThreads]
     * @param {number} [topicId]
     * @param {string} [stage]
     * @param {QueryThreadGetBulkThreadsOrderByEnum} [orderBy]
     * @param {number} [cursor]
     * @param {number} [limit] The number of objects returned
     * @param {number} [offset] The amount of objects offset from the beginning
     * @param {number} [page] The page returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryThreadGetBulkThreads: async (
      communityId: string,
      addressId?: string,
      fromDate?: string,
      toDate?: string,
      archived?: boolean,
      includePinnedThreads?: boolean,
      topicId?: number,
      stage?: string,
      orderBy?: QueryThreadGetBulkThreadsOrderByEnum,
      cursor?: number,
      limit?: number,
      offset?: number,
      page?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'communityId' is not null or undefined
      assertParamExists(
        'queryThreadGetBulkThreads',
        'communityId',
        communityId,
      );
      const localVarPath = `/query/GetBulkThreads`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (communityId !== undefined) {
        localVarQueryParameter['community_id'] = communityId;
      }

      if (fromDate !== undefined) {
        localVarQueryParameter['fromDate'] =
          (fromDate as any) instanceof Date
            ? (fromDate as any).toISOString()
            : fromDate;
      }

      if (toDate !== undefined) {
        localVarQueryParameter['toDate'] =
          (toDate as any) instanceof Date
            ? (toDate as any).toISOString()
            : toDate;
      }

      if (archived !== undefined) {
        localVarQueryParameter['archived'] = archived;
      }

      if (includePinnedThreads !== undefined) {
        localVarQueryParameter['includePinnedThreads'] = includePinnedThreads;
      }

      if (topicId !== undefined) {
        localVarQueryParameter['topicId'] = topicId;
      }

      if (stage !== undefined) {
        localVarQueryParameter['stage'] = stage;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy;
      }

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {string} [addressId]
     * @param {boolean} [includeNodeInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryCommunityGetCommunity(
      id: string,
      addressId?: string,
      includeNodeInfo?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<QueryCommunityGetCommunity200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryCommunityGetCommunity(
          id,
          addressId,
          includeNodeInfo,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.queryCommunityGetCommunity']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {number | null} [limit]
     * @param {number | null} [cursor] required for tRPC useInfiniteQuery hook, equivalent to page number
     * @param {QueryCommunityGetMembersOrderByEnum} [orderBy]
     * @param {QueryCommunityGetMembersOrderDirectionEnum} [orderDirection]
     * @param {string} [search]
     * @param {boolean} [includeRoles]
     * @param {QueryCommunityGetMembersMembershipsParameter} [memberships]
     * @param {boolean} [includeGroupIds]
     * @param {boolean} [includeStakeBalances]
     * @param {string} [allowedAddresses]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryCommunityGetMembers(
      communityId: string,
      addressId?: string,
      limit?: number | null,
      cursor?: number | null,
      orderBy?: QueryCommunityGetMembersOrderByEnum,
      orderDirection?: QueryCommunityGetMembersOrderDirectionEnum,
      search?: string,
      includeRoles?: boolean,
      memberships?: QueryCommunityGetMembersMembershipsParameter,
      includeGroupIds?: boolean,
      includeStakeBalances?: boolean,
      allowedAddresses?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<QueryCommunityGetMembers200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryCommunityGetMembers(
          communityId,
          addressId,
          limit,
          cursor,
          orderBy,
          orderDirection,
          search,
          includeRoles,
          memberships,
          includeGroupIds,
          includeStakeBalances,
          allowedAddresses,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.queryCommunityGetMembers']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {number} [stakeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryCommunityGetStake(
      communityId: string,
      addressId?: string,
      stakeId?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<QueryCommunityGetStake200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryCommunityGetStake(
          communityId,
          addressId,
          stakeId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.queryCommunityGetStake']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {number} pastDateEpoch
     * @param {string} [addressId]
     * @param {string} [communityId]
     * @param {number} [stakeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryCommunityGetStakeHistoricalPrice(
      pastDateEpoch: number,
      addressId?: string,
      communityId?: string,
      stakeId?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<
        Array<QueryCommunityGetStakeHistoricalPrice200ResponseInner>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryCommunityGetStakeHistoricalPrice(
          pastDateEpoch,
          addressId,
          communityId,
          stakeId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.queryCommunityGetStakeHistoricalPrice']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {string} [addresses]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryCommunityGetStakeTransaction(
      addressId?: string,
      addresses?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<
        Array<QueryCommunityGetStakeTransaction200ResponseInner>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryCommunityGetStakeTransaction(
          addressId,
          addresses,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.queryCommunityGetStakeTransaction']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {string} [contestAddress]
     * @param {number} [contestId]
     * @param {boolean} [running]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryContestGetAllContests(
      communityId: string,
      addressId?: string,
      contestAddress?: string,
      contestId?: number,
      running?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<QueryContestGetAllContests200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryContestGetAllContests(
          communityId,
          addressId,
          contestAddress,
          contestId,
          running,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.queryContestGetAllContests']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} contestAddress
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryContestGetContestLog(
      contestAddress: string,
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<QueryContestGetContestLog200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryContestGetContestLog(
          contestAddress,
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.queryContestGetContestLog']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryFeedGetChainActivity(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<QueryFeedGetChainActivity200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryFeedGetChainActivity(
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.queryFeedGetChainActivity']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryFeedGetGlobalActivity(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<QueryFeedGetUserActivity200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryFeedGetGlobalActivity(
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.queryFeedGetGlobalActivity']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryFeedGetUserActivity(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<QueryFeedGetUserActivity200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryFeedGetUserActivity(
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.queryFeedGetUserActivity']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async querySubscriptionGetCommentSubscriptions(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<
        Array<MutationSubscriptionCreateCommentSubscription200Response>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.querySubscriptionGetCommentSubscriptions(
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'QueryApi.querySubscriptionGetCommentSubscriptions'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async querySubscriptionGetCommunityAlerts(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<
        Array<MutationSubscriptionCreateCommunityAlert200Response>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.querySubscriptionGetCommunityAlerts(
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.querySubscriptionGetCommunityAlerts']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async querySubscriptionGetSubscriptionPreferences(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<QuerySubscriptionGetSubscriptionPreferences200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.querySubscriptionGetSubscriptionPreferences(
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'QueryApi.querySubscriptionGetSubscriptionPreferences'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async querySubscriptionGetThreadSubscriptions(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<
        Array<MutationSubscriptionCreateThreadSubscription200Response>
      >
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.querySubscriptionGetThreadSubscriptions(
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'QueryApi.querySubscriptionGetThreadSubscriptions'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {string} [fromDate]
     * @param {string} [toDate]
     * @param {boolean} [archived]
     * @param {boolean} [includePinnedThreads]
     * @param {number} [topicId]
     * @param {string} [stage]
     * @param {QueryThreadGetBulkThreadsOrderByEnum} [orderBy]
     * @param {number} [cursor]
     * @param {number} [limit] The number of objects returned
     * @param {number} [offset] The amount of objects offset from the beginning
     * @param {number} [page] The page returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryThreadGetBulkThreads(
      communityId: string,
      addressId?: string,
      fromDate?: string,
      toDate?: string,
      archived?: boolean,
      includePinnedThreads?: boolean,
      topicId?: number,
      stage?: string,
      orderBy?: QueryThreadGetBulkThreadsOrderByEnum,
      cursor?: number,
      limit?: number,
      offset?: number,
      page?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<QueryThreadGetBulkThreads200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryThreadGetBulkThreads(
          communityId,
          addressId,
          fromDate,
          toDate,
          archived,
          includePinnedThreads,
          topicId,
          stage,
          orderBy,
          cursor,
          limit,
          offset,
          page,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.queryThreadGetBulkThreads']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = QueryApiFp(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {string} [addressId]
     * @param {boolean} [includeNodeInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryCommunityGetCommunity(
      id: string,
      addressId?: string,
      includeNodeInfo?: boolean,
      options?: any,
    ): AxiosPromise<QueryCommunityGetCommunity200Response> {
      return localVarFp
        .queryCommunityGetCommunity(id, addressId, includeNodeInfo, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {number | null} [limit]
     * @param {number | null} [cursor] required for tRPC useInfiniteQuery hook, equivalent to page number
     * @param {QueryCommunityGetMembersOrderByEnum} [orderBy]
     * @param {QueryCommunityGetMembersOrderDirectionEnum} [orderDirection]
     * @param {string} [search]
     * @param {boolean} [includeRoles]
     * @param {QueryCommunityGetMembersMembershipsParameter} [memberships]
     * @param {boolean} [includeGroupIds]
     * @param {boolean} [includeStakeBalances]
     * @param {string} [allowedAddresses]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryCommunityGetMembers(
      communityId: string,
      addressId?: string,
      limit?: number | null,
      cursor?: number | null,
      orderBy?: QueryCommunityGetMembersOrderByEnum,
      orderDirection?: QueryCommunityGetMembersOrderDirectionEnum,
      search?: string,
      includeRoles?: boolean,
      memberships?: QueryCommunityGetMembersMembershipsParameter,
      includeGroupIds?: boolean,
      includeStakeBalances?: boolean,
      allowedAddresses?: string,
      options?: any,
    ): AxiosPromise<QueryCommunityGetMembers200Response> {
      return localVarFp
        .queryCommunityGetMembers(
          communityId,
          addressId,
          limit,
          cursor,
          orderBy,
          orderDirection,
          search,
          includeRoles,
          memberships,
          includeGroupIds,
          includeStakeBalances,
          allowedAddresses,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {number} [stakeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryCommunityGetStake(
      communityId: string,
      addressId?: string,
      stakeId?: number,
      options?: any,
    ): AxiosPromise<QueryCommunityGetStake200Response> {
      return localVarFp
        .queryCommunityGetStake(communityId, addressId, stakeId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} pastDateEpoch
     * @param {string} [addressId]
     * @param {string} [communityId]
     * @param {number} [stakeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryCommunityGetStakeHistoricalPrice(
      pastDateEpoch: number,
      addressId?: string,
      communityId?: string,
      stakeId?: number,
      options?: any,
    ): AxiosPromise<
      Array<QueryCommunityGetStakeHistoricalPrice200ResponseInner>
    > {
      return localVarFp
        .queryCommunityGetStakeHistoricalPrice(
          pastDateEpoch,
          addressId,
          communityId,
          stakeId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {string} [addresses]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryCommunityGetStakeTransaction(
      addressId?: string,
      addresses?: string,
      options?: any,
    ): AxiosPromise<Array<QueryCommunityGetStakeTransaction200ResponseInner>> {
      return localVarFp
        .queryCommunityGetStakeTransaction(addressId, addresses, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {string} [contestAddress]
     * @param {number} [contestId]
     * @param {boolean} [running]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryContestGetAllContests(
      communityId: string,
      addressId?: string,
      contestAddress?: string,
      contestId?: number,
      running?: boolean,
      options?: any,
    ): AxiosPromise<Array<QueryContestGetAllContests200ResponseInner>> {
      return localVarFp
        .queryContestGetAllContests(
          communityId,
          addressId,
          contestAddress,
          contestId,
          running,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} contestAddress
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryContestGetContestLog(
      contestAddress: string,
      addressId?: string,
      options?: any,
    ): AxiosPromise<Array<QueryContestGetContestLog200ResponseInner>> {
      return localVarFp
        .queryContestGetContestLog(contestAddress, addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryFeedGetChainActivity(
      addressId?: string,
      options?: any,
    ): AxiosPromise<Array<QueryFeedGetChainActivity200ResponseInner>> {
      return localVarFp
        .queryFeedGetChainActivity(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryFeedGetGlobalActivity(
      addressId?: string,
      options?: any,
    ): AxiosPromise<Array<QueryFeedGetUserActivity200ResponseInner>> {
      return localVarFp
        .queryFeedGetGlobalActivity(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryFeedGetUserActivity(
      addressId?: string,
      options?: any,
    ): AxiosPromise<Array<QueryFeedGetUserActivity200ResponseInner>> {
      return localVarFp
        .queryFeedGetUserActivity(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    querySubscriptionGetCommentSubscriptions(
      addressId?: string,
      options?: any,
    ): AxiosPromise<
      Array<MutationSubscriptionCreateCommentSubscription200Response>
    > {
      return localVarFp
        .querySubscriptionGetCommentSubscriptions(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    querySubscriptionGetCommunityAlerts(
      addressId?: string,
      options?: any,
    ): AxiosPromise<
      Array<MutationSubscriptionCreateCommunityAlert200Response>
    > {
      return localVarFp
        .querySubscriptionGetCommunityAlerts(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    querySubscriptionGetSubscriptionPreferences(
      addressId?: string,
      options?: any,
    ): AxiosPromise<QuerySubscriptionGetSubscriptionPreferences200Response> {
      return localVarFp
        .querySubscriptionGetSubscriptionPreferences(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    querySubscriptionGetThreadSubscriptions(
      addressId?: string,
      options?: any,
    ): AxiosPromise<
      Array<MutationSubscriptionCreateThreadSubscription200Response>
    > {
      return localVarFp
        .querySubscriptionGetThreadSubscriptions(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {string} [fromDate]
     * @param {string} [toDate]
     * @param {boolean} [archived]
     * @param {boolean} [includePinnedThreads]
     * @param {number} [topicId]
     * @param {string} [stage]
     * @param {QueryThreadGetBulkThreadsOrderByEnum} [orderBy]
     * @param {number} [cursor]
     * @param {number} [limit] The number of objects returned
     * @param {number} [offset] The amount of objects offset from the beginning
     * @param {number} [page] The page returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryThreadGetBulkThreads(
      communityId: string,
      addressId?: string,
      fromDate?: string,
      toDate?: string,
      archived?: boolean,
      includePinnedThreads?: boolean,
      topicId?: number,
      stage?: string,
      orderBy?: QueryThreadGetBulkThreadsOrderByEnum,
      cursor?: number,
      limit?: number,
      offset?: number,
      page?: number,
      options?: any,
    ): AxiosPromise<QueryThreadGetBulkThreads200Response> {
      return localVarFp
        .queryThreadGetBulkThreads(
          communityId,
          addressId,
          fromDate,
          toDate,
          archived,
          includePinnedThreads,
          topicId,
          stage,
          orderBy,
          cursor,
          limit,
          offset,
          page,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
  /**
   *
   * @param {string} id
   * @param {string} [addressId]
   * @param {boolean} [includeNodeInfo]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public queryCommunityGetCommunity(
    id: string,
    addressId?: string,
    includeNodeInfo?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .queryCommunityGetCommunity(id, addressId, includeNodeInfo, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} communityId
   * @param {string} [addressId]
   * @param {number | null} [limit]
   * @param {number | null} [cursor] required for tRPC useInfiniteQuery hook, equivalent to page number
   * @param {QueryCommunityGetMembersOrderByEnum} [orderBy]
   * @param {QueryCommunityGetMembersOrderDirectionEnum} [orderDirection]
   * @param {string} [search]
   * @param {boolean} [includeRoles]
   * @param {QueryCommunityGetMembersMembershipsParameter} [memberships]
   * @param {boolean} [includeGroupIds]
   * @param {boolean} [includeStakeBalances]
   * @param {string} [allowedAddresses]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public queryCommunityGetMembers(
    communityId: string,
    addressId?: string,
    limit?: number | null,
    cursor?: number | null,
    orderBy?: QueryCommunityGetMembersOrderByEnum,
    orderDirection?: QueryCommunityGetMembersOrderDirectionEnum,
    search?: string,
    includeRoles?: boolean,
    memberships?: QueryCommunityGetMembersMembershipsParameter,
    includeGroupIds?: boolean,
    includeStakeBalances?: boolean,
    allowedAddresses?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .queryCommunityGetMembers(
        communityId,
        addressId,
        limit,
        cursor,
        orderBy,
        orderDirection,
        search,
        includeRoles,
        memberships,
        includeGroupIds,
        includeStakeBalances,
        allowedAddresses,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} communityId
   * @param {string} [addressId]
   * @param {number} [stakeId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public queryCommunityGetStake(
    communityId: string,
    addressId?: string,
    stakeId?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .queryCommunityGetStake(communityId, addressId, stakeId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} pastDateEpoch
   * @param {string} [addressId]
   * @param {string} [communityId]
   * @param {number} [stakeId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public queryCommunityGetStakeHistoricalPrice(
    pastDateEpoch: number,
    addressId?: string,
    communityId?: string,
    stakeId?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .queryCommunityGetStakeHistoricalPrice(
        pastDateEpoch,
        addressId,
        communityId,
        stakeId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {string} [addresses]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public queryCommunityGetStakeTransaction(
    addressId?: string,
    addresses?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .queryCommunityGetStakeTransaction(addressId, addresses, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} communityId
   * @param {string} [addressId]
   * @param {string} [contestAddress]
   * @param {number} [contestId]
   * @param {boolean} [running]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public queryContestGetAllContests(
    communityId: string,
    addressId?: string,
    contestAddress?: string,
    contestId?: number,
    running?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .queryContestGetAllContests(
        communityId,
        addressId,
        contestAddress,
        contestId,
        running,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} contestAddress
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public queryContestGetContestLog(
    contestAddress: string,
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .queryContestGetContestLog(contestAddress, addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public queryFeedGetChainActivity(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .queryFeedGetChainActivity(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public queryFeedGetGlobalActivity(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .queryFeedGetGlobalActivity(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public queryFeedGetUserActivity(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .queryFeedGetUserActivity(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public querySubscriptionGetCommentSubscriptions(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .querySubscriptionGetCommentSubscriptions(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public querySubscriptionGetCommunityAlerts(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .querySubscriptionGetCommunityAlerts(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public querySubscriptionGetSubscriptionPreferences(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .querySubscriptionGetSubscriptionPreferences(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public querySubscriptionGetThreadSubscriptions(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .querySubscriptionGetThreadSubscriptions(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} communityId
   * @param {string} [addressId]
   * @param {string} [fromDate]
   * @param {string} [toDate]
   * @param {boolean} [archived]
   * @param {boolean} [includePinnedThreads]
   * @param {number} [topicId]
   * @param {string} [stage]
   * @param {QueryThreadGetBulkThreadsOrderByEnum} [orderBy]
   * @param {number} [cursor]
   * @param {number} [limit] The number of objects returned
   * @param {number} [offset] The amount of objects offset from the beginning
   * @param {number} [page] The page returned
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public queryThreadGetBulkThreads(
    communityId: string,
    addressId?: string,
    fromDate?: string,
    toDate?: string,
    archived?: boolean,
    includePinnedThreads?: boolean,
    topicId?: number,
    stage?: string,
    orderBy?: QueryThreadGetBulkThreadsOrderByEnum,
    cursor?: number,
    limit?: number,
    offset?: number,
    page?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .queryThreadGetBulkThreads(
        communityId,
        addressId,
        fromDate,
        toDate,
        archived,
        includePinnedThreads,
        topicId,
        stage,
        orderBy,
        cursor,
        limit,
        offset,
        page,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const QueryCommunityGetMembersOrderByEnum = {
  LastActive: 'last_active',
  Name: 'name',
} as const;
export type QueryCommunityGetMembersOrderByEnum =
  typeof QueryCommunityGetMembersOrderByEnum[keyof typeof QueryCommunityGetMembersOrderByEnum];
/**
 * @export
 */
export const QueryCommunityGetMembersOrderDirectionEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
export type QueryCommunityGetMembersOrderDirectionEnum =
  typeof QueryCommunityGetMembersOrderDirectionEnum[keyof typeof QueryCommunityGetMembersOrderDirectionEnum];
/**
 * @export
 */
export const QueryThreadGetBulkThreadsOrderByEnum = {
  CreatedAtasc: 'createdAt:asc',
  CreatedAtdesc: 'createdAt:desc',
  NumberOfCommentsasc: 'numberOfComments:asc',
  NumberOfCommentsdesc: 'numberOfComments:desc',
  NumberOfLikesasc: 'numberOfLikes:asc',
  NumberOfLikesdesc: 'numberOfLikes:desc',
  LatestActivityasc: 'latestActivity:asc',
  LatestActivitydesc: 'latestActivity:desc',
} as const;
export type QueryThreadGetBulkThreadsOrderByEnum =
  typeof QueryThreadGetBulkThreadsOrderByEnum[keyof typeof QueryThreadGetBulkThreadsOrderByEnum];

/**
 * SubscriptionApi - axios parameter creator
 * @export
 */
export const SubscriptionApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionCreateCommentSubscriptionRequest} mutationSubscriptionCreateCommentSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionCreateCommentSubscription: async (
      addressId: string,
      id: number,
      mutationSubscriptionCreateCommentSubscriptionRequest: MutationSubscriptionCreateCommentSubscriptionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'mutationSubscriptionCreateCommentSubscription',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'mutationSubscriptionCreateCommentSubscription',
        'id',
        id,
      );
      // verify required parameter 'mutationSubscriptionCreateCommentSubscriptionRequest' is not null or undefined
      assertParamExists(
        'mutationSubscriptionCreateCommentSubscription',
        'mutationSubscriptionCreateCommentSubscriptionRequest',
        mutationSubscriptionCreateCommentSubscriptionRequest,
      );
      const localVarPath =
        `/subscription/{id}/CreateCommentSubscription`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(id)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationSubscriptionCreateCommentSubscriptionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionCreateCommunityAlertRequest} mutationSubscriptionCreateCommunityAlertRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionCreateCommunityAlert: async (
      addressId: string,
      id: number,
      mutationSubscriptionCreateCommunityAlertRequest: MutationSubscriptionCreateCommunityAlertRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'mutationSubscriptionCreateCommunityAlert',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('mutationSubscriptionCreateCommunityAlert', 'id', id);
      // verify required parameter 'mutationSubscriptionCreateCommunityAlertRequest' is not null or undefined
      assertParamExists(
        'mutationSubscriptionCreateCommunityAlert',
        'mutationSubscriptionCreateCommunityAlertRequest',
        mutationSubscriptionCreateCommunityAlertRequest,
      );
      const localVarPath = `/subscription/{id}/CreateCommunityAlert`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationSubscriptionCreateCommunityAlertRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionCreateThreadSubscriptionRequest} mutationSubscriptionCreateThreadSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionCreateThreadSubscription: async (
      addressId: string,
      id: number,
      mutationSubscriptionCreateThreadSubscriptionRequest: MutationSubscriptionCreateThreadSubscriptionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'mutationSubscriptionCreateThreadSubscription',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'mutationSubscriptionCreateThreadSubscription',
        'id',
        id,
      );
      // verify required parameter 'mutationSubscriptionCreateThreadSubscriptionRequest' is not null or undefined
      assertParamExists(
        'mutationSubscriptionCreateThreadSubscription',
        'mutationSubscriptionCreateThreadSubscriptionRequest',
        mutationSubscriptionCreateThreadSubscriptionRequest,
      );
      const localVarPath =
        `/subscription/{id}/CreateThreadSubscription`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(id)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationSubscriptionCreateThreadSubscriptionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionDeleteCommentSubscriptionRequest} mutationSubscriptionDeleteCommentSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionDeleteCommentSubscription: async (
      addressId: string,
      id: number,
      mutationSubscriptionDeleteCommentSubscriptionRequest: MutationSubscriptionDeleteCommentSubscriptionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'mutationSubscriptionDeleteCommentSubscription',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'mutationSubscriptionDeleteCommentSubscription',
        'id',
        id,
      );
      // verify required parameter 'mutationSubscriptionDeleteCommentSubscriptionRequest' is not null or undefined
      assertParamExists(
        'mutationSubscriptionDeleteCommentSubscription',
        'mutationSubscriptionDeleteCommentSubscriptionRequest',
        mutationSubscriptionDeleteCommentSubscriptionRequest,
      );
      const localVarPath =
        `/subscription/{id}/DeleteCommentSubscription`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(id)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationSubscriptionDeleteCommentSubscriptionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionDeleteCommunityAlertRequest} mutationSubscriptionDeleteCommunityAlertRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionDeleteCommunityAlert: async (
      addressId: string,
      id: number,
      mutationSubscriptionDeleteCommunityAlertRequest: MutationSubscriptionDeleteCommunityAlertRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'mutationSubscriptionDeleteCommunityAlert',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('mutationSubscriptionDeleteCommunityAlert', 'id', id);
      // verify required parameter 'mutationSubscriptionDeleteCommunityAlertRequest' is not null or undefined
      assertParamExists(
        'mutationSubscriptionDeleteCommunityAlert',
        'mutationSubscriptionDeleteCommunityAlertRequest',
        mutationSubscriptionDeleteCommunityAlertRequest,
      );
      const localVarPath = `/subscription/{id}/DeleteCommunityAlerts`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationSubscriptionDeleteCommunityAlertRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionDeleteThreadSubscriptionRequest} mutationSubscriptionDeleteThreadSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionDeleteThreadSubscription: async (
      addressId: string,
      id: number,
      mutationSubscriptionDeleteThreadSubscriptionRequest: MutationSubscriptionDeleteThreadSubscriptionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'mutationSubscriptionDeleteThreadSubscription',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'mutationSubscriptionDeleteThreadSubscription',
        'id',
        id,
      );
      // verify required parameter 'mutationSubscriptionDeleteThreadSubscriptionRequest' is not null or undefined
      assertParamExists(
        'mutationSubscriptionDeleteThreadSubscription',
        'mutationSubscriptionDeleteThreadSubscriptionRequest',
        mutationSubscriptionDeleteThreadSubscriptionRequest,
      );
      const localVarPath =
        `/subscription/{id}/DeleteThreadSubscription`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(id)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationSubscriptionDeleteThreadSubscriptionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionRegisterClientRegistrationTokenRequest} mutationSubscriptionRegisterClientRegistrationTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionRegisterClientRegistrationToken: async (
      addressId: string,
      id: number,
      mutationSubscriptionRegisterClientRegistrationTokenRequest: MutationSubscriptionRegisterClientRegistrationTokenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'mutationSubscriptionRegisterClientRegistrationToken',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'mutationSubscriptionRegisterClientRegistrationToken',
        'id',
        id,
      );
      // verify required parameter 'mutationSubscriptionRegisterClientRegistrationTokenRequest' is not null or undefined
      assertParamExists(
        'mutationSubscriptionRegisterClientRegistrationToken',
        'mutationSubscriptionRegisterClientRegistrationTokenRequest',
        mutationSubscriptionRegisterClientRegistrationTokenRequest,
      );
      const localVarPath =
        `/subscription/{id}/RegisterClientRegistrationToken`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(id)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationSubscriptionRegisterClientRegistrationTokenRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionRegisterClientRegistrationTokenRequest} mutationSubscriptionRegisterClientRegistrationTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionUnregisterClientRegistrationToken: async (
      addressId: string,
      id: number,
      mutationSubscriptionRegisterClientRegistrationTokenRequest: MutationSubscriptionRegisterClientRegistrationTokenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'mutationSubscriptionUnregisterClientRegistrationToken',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'mutationSubscriptionUnregisterClientRegistrationToken',
        'id',
        id,
      );
      // verify required parameter 'mutationSubscriptionRegisterClientRegistrationTokenRequest' is not null or undefined
      assertParamExists(
        'mutationSubscriptionUnregisterClientRegistrationToken',
        'mutationSubscriptionRegisterClientRegistrationTokenRequest',
        mutationSubscriptionRegisterClientRegistrationTokenRequest,
      );
      const localVarPath =
        `/subscription/{id}/UnregisterClientRegistrationToken`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(id)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationSubscriptionRegisterClientRegistrationTokenRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionUpdateSubscriptionPreferencesRequest} mutationSubscriptionUpdateSubscriptionPreferencesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionUpdateSubscriptionPreferences: async (
      addressId: string,
      id: number,
      mutationSubscriptionUpdateSubscriptionPreferencesRequest: MutationSubscriptionUpdateSubscriptionPreferencesRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'mutationSubscriptionUpdateSubscriptionPreferences',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'mutationSubscriptionUpdateSubscriptionPreferences',
        'id',
        id,
      );
      // verify required parameter 'mutationSubscriptionUpdateSubscriptionPreferencesRequest' is not null or undefined
      assertParamExists(
        'mutationSubscriptionUpdateSubscriptionPreferences',
        'mutationSubscriptionUpdateSubscriptionPreferencesRequest',
        mutationSubscriptionUpdateSubscriptionPreferencesRequest,
      );
      const localVarPath =
        `/subscription/{id}/UpdateSubscriptionPreferences`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(id)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationSubscriptionUpdateSubscriptionPreferencesRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SubscriptionApi - functional programming interface
 * @export
 */
export const SubscriptionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SubscriptionApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionCreateCommentSubscriptionRequest} mutationSubscriptionCreateCommentSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationSubscriptionCreateCommentSubscription(
      addressId: string,
      id: number,
      mutationSubscriptionCreateCommentSubscriptionRequest: MutationSubscriptionCreateCommentSubscriptionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MutationSubscriptionCreateCommentSubscription200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationSubscriptionCreateCommentSubscription(
          addressId,
          id,
          mutationSubscriptionCreateCommentSubscriptionRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.mutationSubscriptionCreateCommentSubscription'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionCreateCommunityAlertRequest} mutationSubscriptionCreateCommunityAlertRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationSubscriptionCreateCommunityAlert(
      addressId: string,
      id: number,
      mutationSubscriptionCreateCommunityAlertRequest: MutationSubscriptionCreateCommunityAlertRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MutationSubscriptionCreateCommunityAlert200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationSubscriptionCreateCommunityAlert(
          addressId,
          id,
          mutationSubscriptionCreateCommunityAlertRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.mutationSubscriptionCreateCommunityAlert'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionCreateThreadSubscriptionRequest} mutationSubscriptionCreateThreadSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationSubscriptionCreateThreadSubscription(
      addressId: string,
      id: number,
      mutationSubscriptionCreateThreadSubscriptionRequest: MutationSubscriptionCreateThreadSubscriptionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MutationSubscriptionCreateThreadSubscription200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationSubscriptionCreateThreadSubscription(
          addressId,
          id,
          mutationSubscriptionCreateThreadSubscriptionRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.mutationSubscriptionCreateThreadSubscription'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionDeleteCommentSubscriptionRequest} mutationSubscriptionDeleteCommentSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationSubscriptionDeleteCommentSubscription(
      addressId: string,
      id: number,
      mutationSubscriptionDeleteCommentSubscriptionRequest: MutationSubscriptionDeleteCommentSubscriptionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationSubscriptionDeleteCommentSubscription(
          addressId,
          id,
          mutationSubscriptionDeleteCommentSubscriptionRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.mutationSubscriptionDeleteCommentSubscription'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionDeleteCommunityAlertRequest} mutationSubscriptionDeleteCommunityAlertRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationSubscriptionDeleteCommunityAlert(
      addressId: string,
      id: number,
      mutationSubscriptionDeleteCommunityAlertRequest: MutationSubscriptionDeleteCommunityAlertRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationSubscriptionDeleteCommunityAlert(
          addressId,
          id,
          mutationSubscriptionDeleteCommunityAlertRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.mutationSubscriptionDeleteCommunityAlert'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionDeleteThreadSubscriptionRequest} mutationSubscriptionDeleteThreadSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationSubscriptionDeleteThreadSubscription(
      addressId: string,
      id: number,
      mutationSubscriptionDeleteThreadSubscriptionRequest: MutationSubscriptionDeleteThreadSubscriptionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationSubscriptionDeleteThreadSubscription(
          addressId,
          id,
          mutationSubscriptionDeleteThreadSubscriptionRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.mutationSubscriptionDeleteThreadSubscription'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionRegisterClientRegistrationTokenRequest} mutationSubscriptionRegisterClientRegistrationTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationSubscriptionRegisterClientRegistrationToken(
      addressId: string,
      id: number,
      mutationSubscriptionRegisterClientRegistrationTokenRequest: MutationSubscriptionRegisterClientRegistrationTokenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationSubscriptionRegisterClientRegistrationToken(
          addressId,
          id,
          mutationSubscriptionRegisterClientRegistrationTokenRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.mutationSubscriptionRegisterClientRegistrationToken'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionRegisterClientRegistrationTokenRequest} mutationSubscriptionRegisterClientRegistrationTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationSubscriptionUnregisterClientRegistrationToken(
      addressId: string,
      id: number,
      mutationSubscriptionRegisterClientRegistrationTokenRequest: MutationSubscriptionRegisterClientRegistrationTokenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationSubscriptionUnregisterClientRegistrationToken(
          addressId,
          id,
          mutationSubscriptionRegisterClientRegistrationTokenRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.mutationSubscriptionUnregisterClientRegistrationToken'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionUpdateSubscriptionPreferencesRequest} mutationSubscriptionUpdateSubscriptionPreferencesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationSubscriptionUpdateSubscriptionPreferences(
      addressId: string,
      id: number,
      mutationSubscriptionUpdateSubscriptionPreferencesRequest: MutationSubscriptionUpdateSubscriptionPreferencesRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationSubscriptionUpdateSubscriptionPreferences(
          addressId,
          id,
          mutationSubscriptionUpdateSubscriptionPreferencesRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.mutationSubscriptionUpdateSubscriptionPreferences'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SubscriptionApi - factory interface
 * @export
 */
export const SubscriptionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SubscriptionApiFp(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionCreateCommentSubscriptionRequest} mutationSubscriptionCreateCommentSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionCreateCommentSubscription(
      addressId: string,
      id: number,
      mutationSubscriptionCreateCommentSubscriptionRequest: MutationSubscriptionCreateCommentSubscriptionRequest,
      options?: any,
    ): AxiosPromise<MutationSubscriptionCreateCommentSubscription200Response> {
      return localVarFp
        .mutationSubscriptionCreateCommentSubscription(
          addressId,
          id,
          mutationSubscriptionCreateCommentSubscriptionRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionCreateCommunityAlertRequest} mutationSubscriptionCreateCommunityAlertRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionCreateCommunityAlert(
      addressId: string,
      id: number,
      mutationSubscriptionCreateCommunityAlertRequest: MutationSubscriptionCreateCommunityAlertRequest,
      options?: any,
    ): AxiosPromise<MutationSubscriptionCreateCommunityAlert200Response> {
      return localVarFp
        .mutationSubscriptionCreateCommunityAlert(
          addressId,
          id,
          mutationSubscriptionCreateCommunityAlertRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionCreateThreadSubscriptionRequest} mutationSubscriptionCreateThreadSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionCreateThreadSubscription(
      addressId: string,
      id: number,
      mutationSubscriptionCreateThreadSubscriptionRequest: MutationSubscriptionCreateThreadSubscriptionRequest,
      options?: any,
    ): AxiosPromise<MutationSubscriptionCreateThreadSubscription200Response> {
      return localVarFp
        .mutationSubscriptionCreateThreadSubscription(
          addressId,
          id,
          mutationSubscriptionCreateThreadSubscriptionRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionDeleteCommentSubscriptionRequest} mutationSubscriptionDeleteCommentSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionDeleteCommentSubscription(
      addressId: string,
      id: number,
      mutationSubscriptionDeleteCommentSubscriptionRequest: MutationSubscriptionDeleteCommentSubscriptionRequest,
      options?: any,
    ): AxiosPromise<number> {
      return localVarFp
        .mutationSubscriptionDeleteCommentSubscription(
          addressId,
          id,
          mutationSubscriptionDeleteCommentSubscriptionRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionDeleteCommunityAlertRequest} mutationSubscriptionDeleteCommunityAlertRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionDeleteCommunityAlert(
      addressId: string,
      id: number,
      mutationSubscriptionDeleteCommunityAlertRequest: MutationSubscriptionDeleteCommunityAlertRequest,
      options?: any,
    ): AxiosPromise<number> {
      return localVarFp
        .mutationSubscriptionDeleteCommunityAlert(
          addressId,
          id,
          mutationSubscriptionDeleteCommunityAlertRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionDeleteThreadSubscriptionRequest} mutationSubscriptionDeleteThreadSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionDeleteThreadSubscription(
      addressId: string,
      id: number,
      mutationSubscriptionDeleteThreadSubscriptionRequest: MutationSubscriptionDeleteThreadSubscriptionRequest,
      options?: any,
    ): AxiosPromise<number> {
      return localVarFp
        .mutationSubscriptionDeleteThreadSubscription(
          addressId,
          id,
          mutationSubscriptionDeleteThreadSubscriptionRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionRegisterClientRegistrationTokenRequest} mutationSubscriptionRegisterClientRegistrationTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionRegisterClientRegistrationToken(
      addressId: string,
      id: number,
      mutationSubscriptionRegisterClientRegistrationTokenRequest: MutationSubscriptionRegisterClientRegistrationTokenRequest,
      options?: any,
    ): AxiosPromise<object> {
      return localVarFp
        .mutationSubscriptionRegisterClientRegistrationToken(
          addressId,
          id,
          mutationSubscriptionRegisterClientRegistrationTokenRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionRegisterClientRegistrationTokenRequest} mutationSubscriptionRegisterClientRegistrationTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionUnregisterClientRegistrationToken(
      addressId: string,
      id: number,
      mutationSubscriptionRegisterClientRegistrationTokenRequest: MutationSubscriptionRegisterClientRegistrationTokenRequest,
      options?: any,
    ): AxiosPromise<object> {
      return localVarFp
        .mutationSubscriptionUnregisterClientRegistrationToken(
          addressId,
          id,
          mutationSubscriptionRegisterClientRegistrationTokenRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationSubscriptionUpdateSubscriptionPreferencesRequest} mutationSubscriptionUpdateSubscriptionPreferencesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationSubscriptionUpdateSubscriptionPreferences(
      addressId: string,
      id: number,
      mutationSubscriptionUpdateSubscriptionPreferencesRequest: MutationSubscriptionUpdateSubscriptionPreferencesRequest,
      options?: any,
    ): AxiosPromise<QuerySubscriptionGetSubscriptionPreferences200ResponseAnyOf> {
      return localVarFp
        .mutationSubscriptionUpdateSubscriptionPreferences(
          addressId,
          id,
          mutationSubscriptionUpdateSubscriptionPreferencesRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
export class SubscriptionApi extends BaseAPI {
  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {MutationSubscriptionCreateCommentSubscriptionRequest} mutationSubscriptionCreateCommentSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public mutationSubscriptionCreateCommentSubscription(
    addressId: string,
    id: number,
    mutationSubscriptionCreateCommentSubscriptionRequest: MutationSubscriptionCreateCommentSubscriptionRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .mutationSubscriptionCreateCommentSubscription(
        addressId,
        id,
        mutationSubscriptionCreateCommentSubscriptionRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {MutationSubscriptionCreateCommunityAlertRequest} mutationSubscriptionCreateCommunityAlertRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public mutationSubscriptionCreateCommunityAlert(
    addressId: string,
    id: number,
    mutationSubscriptionCreateCommunityAlertRequest: MutationSubscriptionCreateCommunityAlertRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .mutationSubscriptionCreateCommunityAlert(
        addressId,
        id,
        mutationSubscriptionCreateCommunityAlertRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {MutationSubscriptionCreateThreadSubscriptionRequest} mutationSubscriptionCreateThreadSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public mutationSubscriptionCreateThreadSubscription(
    addressId: string,
    id: number,
    mutationSubscriptionCreateThreadSubscriptionRequest: MutationSubscriptionCreateThreadSubscriptionRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .mutationSubscriptionCreateThreadSubscription(
        addressId,
        id,
        mutationSubscriptionCreateThreadSubscriptionRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {MutationSubscriptionDeleteCommentSubscriptionRequest} mutationSubscriptionDeleteCommentSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public mutationSubscriptionDeleteCommentSubscription(
    addressId: string,
    id: number,
    mutationSubscriptionDeleteCommentSubscriptionRequest: MutationSubscriptionDeleteCommentSubscriptionRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .mutationSubscriptionDeleteCommentSubscription(
        addressId,
        id,
        mutationSubscriptionDeleteCommentSubscriptionRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {MutationSubscriptionDeleteCommunityAlertRequest} mutationSubscriptionDeleteCommunityAlertRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public mutationSubscriptionDeleteCommunityAlert(
    addressId: string,
    id: number,
    mutationSubscriptionDeleteCommunityAlertRequest: MutationSubscriptionDeleteCommunityAlertRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .mutationSubscriptionDeleteCommunityAlert(
        addressId,
        id,
        mutationSubscriptionDeleteCommunityAlertRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {MutationSubscriptionDeleteThreadSubscriptionRequest} mutationSubscriptionDeleteThreadSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public mutationSubscriptionDeleteThreadSubscription(
    addressId: string,
    id: number,
    mutationSubscriptionDeleteThreadSubscriptionRequest: MutationSubscriptionDeleteThreadSubscriptionRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .mutationSubscriptionDeleteThreadSubscription(
        addressId,
        id,
        mutationSubscriptionDeleteThreadSubscriptionRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {MutationSubscriptionRegisterClientRegistrationTokenRequest} mutationSubscriptionRegisterClientRegistrationTokenRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public mutationSubscriptionRegisterClientRegistrationToken(
    addressId: string,
    id: number,
    mutationSubscriptionRegisterClientRegistrationTokenRequest: MutationSubscriptionRegisterClientRegistrationTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .mutationSubscriptionRegisterClientRegistrationToken(
        addressId,
        id,
        mutationSubscriptionRegisterClientRegistrationTokenRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {MutationSubscriptionRegisterClientRegistrationTokenRequest} mutationSubscriptionRegisterClientRegistrationTokenRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public mutationSubscriptionUnregisterClientRegistrationToken(
    addressId: string,
    id: number,
    mutationSubscriptionRegisterClientRegistrationTokenRequest: MutationSubscriptionRegisterClientRegistrationTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .mutationSubscriptionUnregisterClientRegistrationToken(
        addressId,
        id,
        mutationSubscriptionRegisterClientRegistrationTokenRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {MutationSubscriptionUpdateSubscriptionPreferencesRequest} mutationSubscriptionUpdateSubscriptionPreferencesRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public mutationSubscriptionUpdateSubscriptionPreferences(
    addressId: string,
    id: number,
    mutationSubscriptionUpdateSubscriptionPreferencesRequest: MutationSubscriptionUpdateSubscriptionPreferencesRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .mutationSubscriptionUpdateSubscriptionPreferences(
        addressId,
        id,
        mutationSubscriptionUpdateSubscriptionPreferencesRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationUserUpdateUserRequest} mutationUserUpdateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationUserUpdateUser: async (
      addressId: string,
      id: number,
      mutationUserUpdateUserRequest: MutationUserUpdateUserRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists('mutationUserUpdateUser', 'addressId', addressId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('mutationUserUpdateUser', 'id', id);
      // verify required parameter 'mutationUserUpdateUserRequest' is not null or undefined
      assertParamExists(
        'mutationUserUpdateUser',
        'mutationUserUpdateUserRequest',
        mutationUserUpdateUserRequest,
      );
      const localVarPath = `/user/{id}/UpdateUser`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mutationUserUpdateUserRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationUserUpdateUserRequest} mutationUserUpdateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mutationUserUpdateUser(
      addressId: string,
      id: number,
      mutationUserUpdateUserRequest: MutationUserUpdateUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MutationUserUpdateUser200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mutationUserUpdateUser(
          addressId,
          id,
          mutationUserUpdateUserRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.mutationUserUpdateUser']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {MutationUserUpdateUserRequest} mutationUserUpdateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mutationUserUpdateUser(
      addressId: string,
      id: number,
      mutationUserUpdateUserRequest: MutationUserUpdateUserRequest,
      options?: any,
    ): AxiosPromise<MutationUserUpdateUser200Response> {
      return localVarFp
        .mutationUserUpdateUser(
          addressId,
          id,
          mutationUserUpdateUserRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {MutationUserUpdateUserRequest} mutationUserUpdateUserRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public mutationUserUpdateUser(
    addressId: string,
    id: number,
    mutationUserUpdateUserRequest: MutationUserUpdateUserRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .mutationUserUpdateUser(
        addressId,
        id,
        mutationUserUpdateUserRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
